import * as THREE from 'three'
import { Canvas, extend, Object3DNode } from '@react-three/fiber'
import { OrbitControls, PerspectiveCamera, useTexture } from '@react-three/drei'

import { aspect_ratio } from '../../contants'
import uv_grid_opengl from '../../textures/uv_grid_opengl.jpg'

// Add class `Line` as `Line_` to react-three-fiber's extend function. This
// makes it so that when you use <line_> in a <Canvas>, the three reconciler
// will use the class `Line`
extend({ Line_: THREE.Line })
// declare `line_` as a JSX element so that typescript doesn't complain
declare global {
  namespace JSX {
      interface IntrinsicElements {
          'line_': Object3DNode<THREE.Line, typeof THREE.Line>,
      }
  }
}

const Shape = ({ shape, color, x, y, z, rx, ry, rz, s }: any) => {
  const texture = useTexture(uv_grid_opengl)
  texture.wrapS =texture.wrapT = THREE.RepeatWrapping
  texture.repeat.set(0.008, 0.008)

  const extrudeSettings = { depth: 8, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 }

  return (
    <group position-y={50}>
      {/* flat shape with texture
				  note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices */}
      <mesh position={[x, y, z-175]} rotation={[rx, ry, rz]} scale={s}>
        <shapeGeometry args={[shape]} />
        <meshPhongMaterial side={THREE.DoubleSide} map={texture} />
      </mesh>

      {/* flat shape */}
      <mesh position={[x, y, z-125]} rotation={[rx, ry, rz]} scale={s} >
        <shapeGeometry args={[shape]} />
        <meshPhongMaterial color={color} side={THREE.DoubleSide} />
      </mesh>

      {/* extruded shape */}
      <mesh position={[x, y, z-75]} rotation={[rx, ry, rz]} scale={s} >
        <extrudeGeometry args={[shape ,extrudeSettings]} />
        <meshPhongMaterial color={color} />
      </mesh>

      <LineShape shape={shape} color={color} x={x} y={y} z={z} rx={rx} r={ry} rz={rz} s={s} />
    </group>
  )
}

const LineShape = ({ shape, color, x, y, z, rx, ry, rz, s }: any) => {
  // lines
  shape.autoClose = true

  const points = shape.getPoints()
  const spacedPoints = shape.getSpacedPoints(50)

  const geometryPoints = new THREE.BufferGeometry().setFromPoints(points)
  const geometrySpacedPoints = new THREE.BufferGeometry().setFromPoints(spacedPoints)

  return (
    <>
      {/* solid line */}
      <line_ geometry={geometryPoints} position={[x, y, z - 25]} rotation={[rx, ry, rz]} scale={s} >
        <lineBasicMaterial color={color} />
      </line_>

      {/* line from equidistance sampled points */}
      <line_ geometry={geometrySpacedPoints} position={[x, y, z + 25]} rotation={[rx, ry, rz]} scale={s} >
        <lineBasicMaterial color={color} />
      </line_>

      {/* vertices from real points */}
      <points geometry={geometryPoints} position={[x, y , z + 75]} rotation={[rx, ry, rz]} scale={s} >
        <pointsMaterial color={color} size={4} />
      </points>

      {/* equidistance sampled points */}
      <points geometry={geometryPoints} position={[x, y , z + 125]} rotation={[rx, ry, rz]} scale={s} >
        <pointsMaterial color={color} size={4} />
      </points>
    </>
  )
}

const Example = () => {
  // California
  const californiaPts = []

  californiaPts.push(new THREE.Vector2(610, 320))
  californiaPts.push(new THREE.Vector2(450, 300))
  californiaPts.push(new THREE.Vector2(392, 392))
  californiaPts.push(new THREE.Vector2(266, 438))
  californiaPts.push(new THREE.Vector2(190, 570))
  californiaPts.push(new THREE.Vector2(190, 600))
  californiaPts.push(new THREE.Vector2(160, 620))
  californiaPts.push(new THREE.Vector2(160, 650))
  californiaPts.push(new THREE.Vector2(180, 640))
  californiaPts.push(new THREE.Vector2(165, 680))
  californiaPts.push(new THREE.Vector2(150, 670))
  californiaPts.push(new THREE.Vector2(90, 737))
  californiaPts.push(new THREE.Vector2(80, 795))
  californiaPts.push(new THREE.Vector2(50, 835))
  californiaPts.push(new THREE.Vector2(64, 870))
  californiaPts.push(new THREE.Vector2(60, 945))
  californiaPts.push(new THREE.Vector2(300, 945))
  californiaPts.push(new THREE.Vector2(300, 743))
  californiaPts.push(new THREE.Vector2(600, 473))
  californiaPts.push(new THREE.Vector2(626, 425))
  californiaPts.push(new THREE.Vector2(600, 370))
  californiaPts.push(new THREE.Vector2(610, 320))

  for (let i = 0; i < californiaPts.length; i ++) californiaPts[i].multiplyScalar(0.25)
  const californiaShape = new THREE.Shape(californiaPts)

  // Triangle
  const triangleShape = new THREE.Shape()
    .moveTo(80, 20)
    .lineTo(40, 80)
    .lineTo(120, 80)
    .lineTo(80, 20) // close path


  // Heart
  const x = 0, y = 0

  const heartShape = new THREE.Shape()
    .moveTo(x + 25, y + 25)
    .bezierCurveTo(x + 25, y + 25, x + 20, y, x, y)
    .bezierCurveTo(x - 30, y, x - 30, y + 35, x - 30, y + 35)
    .bezierCurveTo(x - 30, y + 55, x - 10, y + 77, x + 25, y + 95)
    .bezierCurveTo(x + 60, y + 77, x + 80, y + 55, x + 80, y + 35)
    .bezierCurveTo(x + 80, y + 35, x + 80, y, x + 50, y)
    .bezierCurveTo(x + 35, y, x + 25, y + 25, x + 25, y + 25)


  // Square
  const sqLength = 80

  const squareShape = new THREE.Shape()
    .moveTo(0, 0)
    .lineTo(0, sqLength)
    .lineTo(sqLength, sqLength)
    .lineTo(sqLength, 0)
    .lineTo(0, 0)

  // Rounded rectangle
  const width=50, height=50, radius=20

  const roundedRectShape = new THREE.Shape()
    .moveTo(x, y + radius)
    .lineTo(x, y + height - radius)
    .quadraticCurveTo(x, y + height, x + radius, y + height)
    .lineTo(x + width - radius, y + height)
    .quadraticCurveTo(x + width, y + height, x + width, y + height - radius)
    .lineTo(x + width, y + radius)
    .quadraticCurveTo(x + width, y, x + width - radius, y)
    .lineTo(x + radius, y)
    .quadraticCurveTo(x, y, x, y + radius)

  // Track
  const trackShape = new THREE.Shape()
    .moveTo(40, 40)
    .lineTo(40, 160)
    .absarc(60, 160, 20, Math.PI, 0, true)
    .lineTo(80, 40)
    .absarc(60, 40, 20, 2 * Math.PI, Math.PI, true)

  // Circle
  const circleRadius = 40
  const circleShape = new THREE.Shape()
    .moveTo(0, circleRadius)
    .quadraticCurveTo(circleRadius, circleRadius, circleRadius, 0)
    .quadraticCurveTo(circleRadius, - circleRadius, 0, - circleRadius)
    .quadraticCurveTo(- circleRadius, - circleRadius, - circleRadius, 0)
    .quadraticCurveTo(- circleRadius, circleRadius, 0, circleRadius)


  // Fish
  const fishShape = new THREE.Shape()
    .moveTo(x, y)
    .quadraticCurveTo(x + 50, y - 80, x + 90, y - 10)
    .quadraticCurveTo(x + 100, y - 10, x + 115, y - 40)
    .quadraticCurveTo(x + 115, y, x + 115, y + 40)
    .quadraticCurveTo(x + 100, y + 10, x + 90, y + 10)
    .quadraticCurveTo(x + 50, y + 80, x, y)


  // Arc circle
  const arcShape = new THREE.Shape()
    .moveTo(50, 10)
    .absarc(10, 10, 40, 0, Math.PI * 2, false)

  const holePath = new THREE.Path()
    .moveTo(20, 10)
    .absarc(10, 10, 10, 0, Math.PI * 2, true)

  arcShape.holes.push(holePath)


  // Smiley
  const smileyShape = new THREE.Shape()
    .moveTo(80, 40)
    .absarc(40, 40, 40, 0, Math.PI * 2, false)

  const smileyEye1Path = new THREE.Path()
    .moveTo(35, 20)
    .absellipse(25, 20, 10, 10, 0, Math.PI * 2, true, 0)

  const smileyEye2Path = new THREE.Path()
    .moveTo(65, 20)
    .absarc(55, 20, 10, 0, Math.PI * 2, true)

  const smileyMouthPath = new THREE.Path()
    .moveTo(20, 40)
    .quadraticCurveTo(40, 60, 60, 40)
    .bezierCurveTo(70, 45, 70, 50, 60, 60)
    .quadraticCurveTo(40, 80, 20, 60)
    .quadraticCurveTo(5, 50, 20, 40)

  smileyShape.holes.push(smileyEye1Path)
  smileyShape.holes.push(smileyEye2Path)
  smileyShape.holes.push(smileyMouthPath)


  // Spline shape
  const splinepts = []
  splinepts.push(new THREE.Vector2(70, 20))
  splinepts.push(new THREE.Vector2(80, 90))
  splinepts.push(new THREE.Vector2(-30, 70))
  splinepts.push(new THREE.Vector2(0, 0))

  const splineShape = new THREE.Shape()
    .moveTo(0, 0)
    .splineThru(splinepts)

  return (
    <Canvas gl={{ antialias: true }}>
      <PerspectiveCamera args={[50, aspect_ratio, 1, 1000]} position={[0, 150, 500]} makeDefault >
        <pointLight args={[0xffffff, 0.8]} />
      </PerspectiveCamera>
      <color attach='background' args={[0xf0f0f0]} />
      <Shape shape={californiaShape} color={0xf08000} x={-300} y={-100} z={0} rx={0} ry={0} rz={0} s={0} />
      <Shape shape={triangleShape} color={0x8080f0} x={-180} y={0} z={0} rx={0} ry={0} rz={0} s={1} />
			<Shape shape={roundedRectShape} color={0x008000} x={-150} y={150} z={0} rx={0} ry={0} rz={0} s={1} />
			<Shape shape={trackShape} color={0x008080} x={200} y={-100} z={0} rx={0} ry={0} rz={0} s={1} />
			<Shape shape={squareShape} color={0x0040f0} x={150} y={100} z={0} rx={0} ry={0} rz={0} s={1} />
			<Shape shape={heartShape} color={0xf00000} x={60} y={100} z={0} rx={0} ry={0} rz={Math.PI} s={1} />
			<Shape shape={circleShape} color={0x00f000} x={120} y={250} z={0} rx={0} ry={0} rz={0} s={1} />
			<Shape shape={fishShape} color={0x404040} x={-60} y={200} z={0} rx={0} ry={0} rz={0} s={1} />
			<Shape shape={smileyShape} color={0xf000f0} x={-200} y={250} z={0} rx={0} ry={0} rz={Math.PI} s={1} />
			<Shape shape={arcShape} color={0x804000} x={150}y ={0} z={0} rx={0} ry={0} rz={0} s={1} />
			<Shape shape={splineShape} color={0x808080} x={-50} y={-100} z={0} rx={0} ry={0} rz={0} s={1} />

      <LineShape shape={arcShape.holes[0]} color={0x804000} x={150} y={0} z={0} rx={0} ry={0} rz={0} s={1} />
      {smileyShape.holes.map((hole, i) => (
        <LineShape key={i} shape={hole} color={0xf000f0} x={-200} y={250} z={0} rx={0} ry={0} rz={Math.PI} s={1} />
      ))}
      <OrbitControls />
    </Canvas>
  )
}

export default Example