{"version":3,"file":"static/js/809.7bb3a2c2.chunk.js","mappings":"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","sources":["../node_modules/three-stdlib/utils/SkeletonUtils.js","webgl/animation_multiple/Example.tsx"],"sourcesContent":["import { Vector3, Quaternion, Matrix4, AnimationMixer, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, SkeletonHelper, Vector2, Euler } from 'three';\n\nvar SkeletonUtils = {\n  retarget: function () {\n    var pos = new Vector3(),\n        quat = new Quaternion(),\n        scale = new Vector3(),\n        bindBoneMatrix = new Matrix4(),\n        relativeMatrix = new Matrix4(),\n        globalMatrix = new Matrix4();\n    return function (target, source, options) {\n      options = options || {};\n      options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n      options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n      options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n      options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          bindBones,\n          bone,\n          name,\n          boneTo,\n          bonesPosition,\n          i; // reset bones\n\n      if (target.isObject3D) {\n        target.skeleton.pose();\n      } else {\n        options.useTargetMatrix = true;\n        options.preserveMatrix = false;\n      }\n\n      if (options.preservePosition) {\n        bonesPosition = [];\n\n        for (i = 0; i < bones.length; i++) {\n          bonesPosition.push(bones[i].position.clone());\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // reset matrix\n        target.updateMatrixWorld();\n        target.matrixWorld.identity(); // reset children matrix\n\n        for (i = 0; i < target.children.length; ++i) {\n          target.children[i].updateMatrixWorld(true);\n        }\n      }\n\n      if (options.offsets) {\n        bindBones = [];\n\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (options.offsets && options.offsets[name]) {\n            bone.matrix.multiply(options.offsets[name]);\n            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n            bone.updateMatrixWorld();\n          }\n\n          bindBones.push(bone.matrixWorld.clone());\n        }\n      }\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n        globalMatrix.copy(bone.matrixWorld);\n\n        if (boneTo) {\n          boneTo.updateMatrixWorld();\n\n          if (options.useTargetMatrix) {\n            relativeMatrix.copy(boneTo.matrixWorld);\n          } else {\n            relativeMatrix.copy(target.matrixWorld).invert();\n            relativeMatrix.multiply(boneTo.matrixWorld);\n          } // ignore scale to extract rotation\n\n\n          scale.setFromMatrixScale(relativeMatrix);\n          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z)); // apply to global matrix\n\n          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n\n          if (target.isObject3D) {\n            var boneIndex = bones.indexOf(bone),\n                wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n            globalMatrix.multiply(wBindMatrix);\n          }\n\n          globalMatrix.copyPosition(relativeMatrix);\n        }\n\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(globalMatrix);\n        } else {\n          bone.matrix.copy(globalMatrix);\n        }\n\n        if (options.preserveHipPosition && name === options.hip) {\n          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n        }\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n\n      if (options.preservePosition) {\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (name !== options.hip) {\n            bone.position.copy(bonesPosition[i]);\n          }\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // restore matrix\n        target.updateMatrixWorld(true);\n      }\n    };\n  }(),\n  retargetClip: function (target, source, clip, options) {\n    options = options || {};\n    options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n    options.fps = options.fps !== undefined ? options.fps : 30;\n    options.names = options.names || [];\n\n    if (!source.isObject3D) {\n      source = this.getHelperFromSkeleton(source);\n    }\n\n    var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n        delta = 1 / options.fps,\n        convertedTracks = [],\n        mixer = new AnimationMixer(source),\n        bones = this.getBones(target.skeleton),\n        boneDatas = [],\n        positionOffset,\n        bone,\n        boneTo,\n        boneData,\n        name,\n        i,\n        j;\n    mixer.clipAction(clip).play();\n    mixer.update(0);\n    source.updateMatrixWorld();\n\n    for (i = 0; i < numFrames; ++i) {\n      var time = i * delta;\n      this.retarget(target, source, options);\n\n      for (j = 0; j < bones.length; ++j) {\n        name = options.names[bones[j].name] || bones[j].name;\n        boneTo = this.getBoneByName(name, source.skeleton);\n\n        if (boneTo) {\n          bone = bones[j];\n          boneData = boneDatas[j] = boneDatas[j] || {\n            bone: bone\n          };\n\n          if (options.hip === name) {\n            if (!boneData.pos) {\n              boneData.pos = {\n                times: new Float32Array(numFrames),\n                values: new Float32Array(numFrames * 3)\n              };\n            }\n\n            if (options.useFirstFramePosition) {\n              if (i === 0) {\n                positionOffset = bone.position.clone();\n              }\n\n              bone.position.sub(positionOffset);\n            }\n\n            boneData.pos.times[i] = time;\n            bone.position.toArray(boneData.pos.values, i * 3);\n          }\n\n          if (!boneData.quat) {\n            boneData.quat = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 4)\n            };\n          }\n\n          boneData.quat.times[i] = time;\n          bone.quaternion.toArray(boneData.quat.values, i * 4);\n        }\n      }\n\n      mixer.update(delta);\n      source.updateMatrixWorld();\n    }\n\n    for (i = 0; i < boneDatas.length; ++i) {\n      boneData = boneDatas[i];\n\n      if (boneData) {\n        if (boneData.pos) {\n          convertedTracks.push(new VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\n        }\n\n        convertedTracks.push(new QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\n      }\n    }\n\n    mixer.uncacheAction(clip);\n    return new AnimationClip(clip.name, -1, convertedTracks);\n  },\n  getHelperFromSkeleton: function (skeleton) {\n    var source = new SkeletonHelper(skeleton.bones[0]);\n    source.skeleton = skeleton;\n    return source;\n  },\n  getSkeletonOffsets: function () {\n    var targetParentPos = new Vector3(),\n        targetPos = new Vector3(),\n        sourceParentPos = new Vector3(),\n        sourcePos = new Vector3(),\n        targetDir = new Vector2(),\n        sourceDir = new Vector2();\n    return function (target, source, options) {\n      options = options || {};\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n\n      if (!source.isObject3D) {\n        source = this.getHelperFromSkeleton(source);\n      }\n\n      var nameKeys = Object.keys(options.names),\n          nameValues = Object.values(options.names),\n          sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          offsets = [],\n          bone,\n          boneTo,\n          name,\n          i;\n      target.skeleton.pose();\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n\n        if (boneTo && name !== options.hip) {\n          var boneParent = this.getNearestBone(bone.parent, nameKeys),\n              boneToParent = this.getNearestBone(boneTo.parent, nameValues);\n          boneParent.updateMatrixWorld();\n          boneToParent.updateMatrixWorld();\n          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\n          targetPos.setFromMatrixPosition(bone.matrixWorld);\n          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\n          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\n          targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();\n          sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\n          var laterialAngle = targetDir.angle() - sourceDir.angle();\n          var offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));\n          bone.matrix.multiply(offset);\n          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n          bone.updateMatrixWorld();\n          offsets[name] = offset;\n        }\n      }\n\n      return offsets;\n    };\n  }(),\n  renameBones: function (skeleton, names) {\n    var bones = this.getBones(skeleton);\n\n    for (let i = 0; i < bones.length; ++i) {\n      var bone = bones[i];\n\n      if (names[bone.name]) {\n        bone.name = names[bone.name];\n      }\n    }\n\n    return this;\n  },\n  getBones: function (skeleton) {\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n  },\n  getBoneByName: function (name, skeleton) {\n    for (let i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {\n      if (name === bones[i].name) return bones[i];\n    }\n  },\n  getNearestBone: function (bone, names) {\n    while (bone.isBone) {\n      if (names.indexOf(bone.name) !== -1) {\n        return bone;\n      }\n\n      bone = bone.parent;\n    }\n  },\n  findBoneTrackData: function (name, tracks) {\n    var regexp = /\\[(.*)\\]\\.(.*)/,\n        result = {\n      name: name\n    };\n\n    for (let i = 0; i < tracks.length; ++i) {\n      // 1 is track name\n      // 2 is track type\n      var trackData = regexp.exec(tracks[i].name);\n\n      if (trackData && name === trackData[1]) {\n        result[trackData[2]] = i;\n      }\n    }\n\n    return result;\n  },\n  getEqualsBonesNames: function (skeleton, targetSkeleton) {\n    var sourceBones = this.getBones(skeleton),\n        targetBones = this.getBones(targetSkeleton),\n        bones = [];\n\n    search: for (let i = 0; i < sourceBones.length; i++) {\n      var boneName = sourceBones[i].name;\n\n      for (let j = 0; j < targetBones.length; j++) {\n        if (boneName === targetBones[j].name) {\n          bones.push(boneName);\n          continue search;\n        }\n      }\n    }\n\n    return bones;\n  },\n  clone: function (source) {\n    var sourceLookup = new Map();\n    var cloneLookup = new Map();\n    var clone = source.clone();\n    parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n      sourceLookup.set(clonedNode, sourceNode);\n      cloneLookup.set(sourceNode, clonedNode);\n    });\n    clone.traverse(function (node) {\n      if (!node.isSkinnedMesh) return;\n      var clonedMesh = node;\n      var sourceMesh = sourceLookup.get(node);\n      var sourceBones = sourceMesh.skeleton.bones;\n      clonedMesh.skeleton = sourceMesh.skeleton.clone();\n      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n        return cloneLookup.get(bone);\n      });\n      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n    });\n    return clone;\n  }\n};\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\n\nexport { SkeletonUtils };\n","import { useEffect } from \"react\"\nimport { AnimationMixer } from \"three\"\nimport { SkeletonUtils } from 'three-stdlib'\nimport { Canvas, useFrame } from \"@react-three/fiber\"\nimport { useGLTF } from \"@react-three/drei\"\n\nimport soldier from '../../models/Soldier.glb'\nuseGLTF.preload(soldier)\n\nconst mixers: AnimationMixer[] = []\n\nconst Model = () => {\n  const { scene, animations }: any = useGLTF(soldier)\n\n  const model1 = SkeletonUtils.clone(scene)\n  const model2 = SkeletonUtils.clone(scene)\n  const model3 = SkeletonUtils.clone(scene)\n\n  const mixer1 = new AnimationMixer(model1)\n  const mixer2 = new AnimationMixer(model2)\n  const mixer3 = new AnimationMixer(model3)\n\n  mixer1.clipAction(animations[0]).play()\n  mixer2.clipAction(animations[1]).play()\n  mixer3.clipAction(animations[3]).play()\n\n  model1.position.x = -2\n  model3.position.x = 2\n\n  mixers.push(mixer1, mixer2, mixer3)\n\n  useEffect(() => {\n    scene.traverse((object: any) => object.isMesh && (object.castShadow = true))\n  }, [scene])\n\n  useFrame((_ ,delta) => {\n    mixers.forEach(mixer => mixer.update(delta))\n  })\n\n  return (\n    <>\n      <primitive object={model1} />\n      <primitive object={model2} />\n      <primitive object={model3} />\n    </>\n  )\n}\n\nconst Ground = () => {\n  return (\n    <mesh rotation={[-Math.PI/2, 0, 0]} receiveShadow>\n      <planeGeometry args={[200, 200]} />\n      <meshPhongMaterial color={0x999999} depthWrite={false} />\n    </mesh>\n  )\n}\n\nconst Example = () => {\n  return (\n    <Canvas\n      camera={{ position: [2, 3, -6], fov: 45, near: 1, far: 1000}}\n      dpr={[1, 2]} shadows\n      onCreated={({ camera }) => camera.lookAt(0, 1, 0)}\n    >\n      <color attach=\"background\" args={[0xa0a0a0]} />\n      <fog attach=\"fog\" args={[0xa0a0a0, 10, 50]} />\n      <hemisphereLight position={[0, 20, 0]} args={[0xffffff, 0x444444]} />\n      <directionalLight position={[-3, 10, -10]} args={[0xffffff]} castShadow\n        // shadow-camera-top={4} shadow-camera-bottom={-4} shadow-camera-left={-4} shadow-camera-right={4}\n        // shadow-camera-near={0.1} shadow-camera-far={40} \n      >\n        <orthographicCamera attach='shadow-camera' args={[-4, 4, 4, -4, 0.1, 40]} />\n      </directionalLight>\n      <Ground />\n      <Model />\n    </Canvas>\n  )\n}\n\nexport default Example"],"names":["SkeletonUtils","pos","Vector3","quat","Quaternion","scale","bindBoneMatrix","Matrix4","relativeMatrix","globalMatrix","targetParentPos","targetPos","sourceParentPos","sourcePos","targetDir","Vector2","sourceDir","source","sourceLookup","Map","cloneLookup","clone","parallelTraverse","sourceNode","clonedNode","set","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","sourceBones","skeleton","bones","bindMatrix","copy","map","bone","bind","a","b","callback","i","children","length","useGLTF","soldier","mixers","Model","scene","animations","model1","model2","model3","mixer1","AnimationMixer","mixer2","mixer3","clipAction","play","position","x","push","useEffect","object","isMesh","castShadow","useFrame","_","delta","forEach","mixer","update","Ground","rotation","Math","PI","receiveShadow","args","color","depthWrite","camera","fov","near","far","dpr","shadows","onCreated","lookAt","attach"],"sourceRoot":""}