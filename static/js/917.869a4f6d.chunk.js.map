{"version":3,"file":"static/js/917.869a4f6d.chunk.js","mappings":"iPAihBA,SAASA,EAAOC,GAEf,IAAMC,EAAe,IAAIC,IACnBC,EAAc,IAAID,IAElBH,EAAQC,EAAOD,QA8BrB,OA5BAK,EAAkBJ,EAAQD,GAAO,SAAWM,EAAYC,GAEvDL,EAAaM,IAAKD,EAAYD,GAC9BF,EAAYI,IAAKF,EAAYC,MAI9BP,EAAMS,UAAU,SAAWC,GAE1B,GAAOA,EAAKC,cAAZ,CAEA,IAAMC,EAAaF,EACbG,EAAaX,EAAaY,IAAKJ,GAC/BK,EAAcF,EAAWG,SAASC,MAExCL,EAAWI,SAAWH,EAAWG,SAAShB,QAC1CY,EAAWM,WAAWC,KAAMN,EAAWK,YAEvCN,EAAWI,SAASC,MAAQF,EAAYK,KAAK,SAAWC,GAEvD,OAAOjB,EAAYU,IAAKO,MAIzBT,EAAWU,KAAMV,EAAWI,SAAUJ,EAAWM,gBAI3ClB,EAOR,SAASK,EAAkBkB,EAAGC,EAAGC,GAEhCA,EAAUF,EAAGC,GAEb,IAAM,IAAIE,EAAI,EAAGA,EAAIH,EAAEI,SAASC,OAAQF,IAEvCrB,EAAkBkB,EAAEI,SAAUD,GAAKF,EAAEG,SAAUD,GAAKD,G,aC3jBhDI,EAAS,UAAMC,+BAAN,uBACfC,EAAAA,EAAAA,QAAgBF,GAEhB,IAAMG,EAA2B,GAE3BC,EAAQ,WACZ,OAA8BF,EAAAA,EAAAA,GAAQF,GAA9BK,EAAR,EAAQA,MAAOC,EAAf,EAAeA,WAETC,EAASC,EAAoBH,GAC7BI,EAASD,EAAoBH,GAC7BK,EAASF,EAAoBH,GAE7BM,EAAS,IAAIC,EAAAA,eAAeL,GAC5BM,EAAS,IAAID,EAAAA,eAAeH,GAC5BK,EAAS,IAAIF,EAAAA,eAAeF,GAmBlC,OAjBAC,EAAOI,WAAWT,EAAW,IAAIU,OACjCH,EAAOE,WAAWT,EAAW,IAAIU,OACjCF,EAAOC,WAAWT,EAAW,IAAIU,OAEjCT,EAAOU,SAASC,GAAK,EACrBR,EAAOO,SAASC,EAAI,EAEpBf,EAAOgB,KAAKR,EAAQE,EAAQC,IAE5BM,EAAAA,EAAAA,YAAU,WACRf,EAAMzB,UAAS,SAACyC,GAAD,OAAiBA,EAAOC,SAAWD,EAAOE,YAAa,QACrE,CAAClB,KAEJmB,EAAAA,EAAAA,IAAS,SAACC,EAAGC,GACXvB,EAAOwB,SAAQ,SAAAC,GAAK,OAAIA,EAAMC,OAAOH,UAIrC,iCACE,sBAAWL,OAAQd,KACnB,sBAAWc,OAAQZ,KACnB,sBAAWY,OAAQX,QAKnBoB,EAAS,WACb,OACE,kBAAMC,SAAU,EAAEC,KAAKC,GAAG,EAAG,EAAG,GAAIC,eAAa,EAAjD,WACE,0BAAeC,KAAM,CAAC,IAAK,QAC3B,8BAAmBC,MAAO,SAAUC,YAAY,QAwBtD,EAnBgB,WACd,OACE,UAAC,KAAD,CACEC,OAAQ,CAAErB,SAAU,CAAC,EAAG,GAAI,GAAIsB,IAAK,GAAIC,KAAM,EAAGC,IAAK,KACvDC,IAAK,CAAC,EAAG,GAAIC,SAAO,EACpBC,UAAW,qBAAGN,OAAoBO,OAAO,EAAG,EAAG,IAHjD,WAKE,kBAAOC,OAAO,aAAaX,KAAM,CAAC,aAClC,gBAAKW,OAAO,MAAMX,KAAM,CAAC,SAAU,GAAI,OACvC,4BAAiBlB,SAAU,CAAC,EAAG,GAAI,GAAIkB,KAAM,CAAC,SAAU,YACxD,6BAAkBlB,SAAU,EAAE,EAAG,IAAK,IAAKkB,KAAM,CAAC,UAAWZ,YAAU,EACrE,oBAAmB,EAAG,wBAAuB,EAAG,sBAAqB,EAAG,sBAAqB,EAC7F,qBAAoB,GAAK,oBAAmB,MAC9C,SAACO,EAAD,KACA,SAAC1B,EAAD","sources":["../node_modules/three/examples/jsm/utils/SkeletonUtils.js","webgl/animation_multiple/Example.tsx"],"sourcesContent":["import {\n\tAnimationClip,\n\tAnimationMixer,\n\tEuler,\n\tMatrix4,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tSkeletonHelper,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack\n} from 'three';\n\n\nfunction retarget( target, source, options = {} ) {\n\n\tconst pos = new Vector3(),\n\t\tquat = new Quaternion(),\n\t\tscale = new Vector3(),\n\t\tbindBoneMatrix = new Matrix4(),\n\t\trelativeMatrix = new Matrix4(),\n\t\tglobalMatrix = new Matrix4();\n\n\toptions.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n\toptions.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n\toptions.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\toptions.names = options.names || {};\n\n\tconst sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target );\n\n\tlet bindBones,\n\t\tbone, name, boneTo,\n\t\tbonesPosition;\n\n\t// reset bones\n\n\tif ( target.isObject3D ) {\n\n\t\ttarget.skeleton.pose();\n\n\t} else {\n\n\t\toptions.useTargetMatrix = true;\n\t\toptions.preserveMatrix = false;\n\n\t}\n\n\tif ( options.preservePosition ) {\n\n\t\tbonesPosition = [];\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tbonesPosition.push( bones[ i ].position.clone() );\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveMatrix ) {\n\n\t\t// reset matrix\n\n\t\ttarget.updateMatrixWorld();\n\n\t\ttarget.matrixWorld.identity();\n\n\t\t// reset children matrix\n\n\t\tfor ( let i = 0; i < target.children.length; ++ i ) {\n\n\t\t\ttarget.children[ i ].updateMatrixWorld( true );\n\n\t\t}\n\n\t}\n\n\tif ( options.offsets ) {\n\n\t\tbindBones = [];\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\tif ( options.offsets[ name ] ) {\n\n\t\t\t\tbone.matrix.multiply( options.offsets[ name ] );\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\tbindBones.push( bone.matrixWorld.clone() );\n\n\t\t}\n\n\t}\n\n\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\tbone = bones[ i ];\n\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\tboneTo = getBoneByName( name, sourceBones );\n\n\t\tglobalMatrix.copy( bone.matrixWorld );\n\n\t\tif ( boneTo ) {\n\n\t\t\tboneTo.updateMatrixWorld();\n\n\t\t\tif ( options.useTargetMatrix ) {\n\n\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\trelativeMatrix.copy( target.matrixWorld ).invert();\n\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\n\n\t\t\t}\n\n\t\t\t// ignore scale to extract rotation\n\n\t\t\tscale.setFromMatrixScale( relativeMatrix );\n\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\n\n\t\t\t// apply to global matrix\n\n\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\n\n\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\tconst boneIndex = bones.indexOf( bone ),\n\t\t\t\t\twBindMatrix = bindBones ? bindBones[ boneIndex ] : bindBoneMatrix.copy( target.skeleton.boneInverses[ boneIndex ] ).invert();\n\n\t\t\t\tglobalMatrix.multiply( wBindMatrix );\n\n\t\t\t}\n\n\t\t\tglobalMatrix.copyPosition( relativeMatrix );\n\n\t\t}\n\n\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\tbone.matrix.multiply( globalMatrix );\n\n\t\t} else {\n\n\t\t\tbone.matrix.copy( globalMatrix );\n\n\t\t}\n\n\t\tif ( options.preserveHipPosition && name === options.hip ) {\n\n\t\t\tbone.matrix.setPosition( pos.set( 0, bone.position.y, 0 ) );\n\n\t\t}\n\n\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\tbone.updateMatrixWorld();\n\n\t}\n\n\tif ( options.preservePosition ) {\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\tif ( name !== options.hip ) {\n\n\t\t\t\tbone.position.copy( bonesPosition[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveMatrix ) {\n\n\t\t// restore matrix\n\n\t\ttarget.updateMatrixWorld( true );\n\n\t}\n\n}\n\nfunction retargetClip( target, source, clip, options = {} ) {\n\n\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\toptions.fps = options.fps !== undefined ? options.fps : 30;\n\toptions.names = options.names || [];\n\n\tif ( ! source.isObject3D ) {\n\n\t\tsource = getHelperFromSkeleton( source );\n\n\t}\n\n\tconst numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\n\t\tdelta = 1 / options.fps,\n\t\tconvertedTracks = [],\n\t\tmixer = new AnimationMixer( source ),\n\t\tbones = getBones( target.skeleton ),\n\t\tboneDatas = [];\n\tlet positionOffset,\n\t\tbone, boneTo, boneData,\n\t\tname;\n\n\tmixer.clipAction( clip ).play();\n\tmixer.update( 0 );\n\n\tsource.updateMatrixWorld();\n\n\tfor ( let i = 0; i < numFrames; ++ i ) {\n\n\t\tconst time = i * delta;\n\n\t\tretarget( target, source, options );\n\n\t\tfor ( let j = 0; j < bones.length; ++ j ) {\n\n\t\t\tname = options.names[ bones[ j ].name ] || bones[ j ].name;\n\n\t\t\tboneTo = getBoneByName( name, source.skeleton );\n\n\t\t\tif ( boneTo ) {\n\n\t\t\t\tbone = bones[ j ];\n\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\n\n\t\t\t\tif ( options.hip === name ) {\n\n\t\t\t\t\tif ( ! boneData.pos ) {\n\n\t\t\t\t\t\tboneData.pos = {\n\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 3 )\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.useFirstFramePosition ) {\n\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbone.position.sub( positionOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.pos.times[ i ] = time;\n\n\t\t\t\t\tbone.position.toArray( boneData.pos.values, i * 3 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! boneData.quat ) {\n\n\t\t\t\t\tboneData.quat = {\n\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\tvalues: new Float32Array( numFrames * 4 )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tboneData.quat.times[ i ] = time;\n\n\t\t\t\tbone.quaternion.toArray( boneData.quat.values, i * 4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tmixer.update( delta );\n\n\t\tsource.updateMatrixWorld();\n\n\t}\n\n\tfor ( let i = 0; i < boneDatas.length; ++ i ) {\n\n\t\tboneData = boneDatas[ i ];\n\n\t\tif ( boneData ) {\n\n\t\t\tif ( boneData.pos ) {\n\n\t\t\t\tconvertedTracks.push( new VectorKeyframeTrack(\n\t\t\t\t\t'.bones[' + boneData.bone.name + '].position',\n\t\t\t\t\tboneData.pos.times,\n\t\t\t\t\tboneData.pos.values\n\t\t\t\t) );\n\n\t\t\t}\n\n\t\t\tconvertedTracks.push( new QuaternionKeyframeTrack(\n\t\t\t\t'.bones[' + boneData.bone.name + '].quaternion',\n\t\t\t\tboneData.quat.times,\n\t\t\t\tboneData.quat.values\n\t\t\t) );\n\n\t\t}\n\n\t}\n\n\tmixer.uncacheAction( clip );\n\n\treturn new AnimationClip( clip.name, - 1, convertedTracks );\n\n}\n\nfunction getHelperFromSkeleton( skeleton ) {\n\n\tconst source = new SkeletonHelper( skeleton.bones[ 0 ] );\n\tsource.skeleton = skeleton;\n\n\treturn source;\n\n}\n\nfunction getSkeletonOffsets( target, source, options = {} ) {\n\n\tconst targetParentPos = new Vector3(),\n\t\ttargetPos = new Vector3(),\n\t\tsourceParentPos = new Vector3(),\n\t\tsourcePos = new Vector3(),\n\t\ttargetDir = new Vector2(),\n\t\tsourceDir = new Vector2();\n\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\toptions.names = options.names || {};\n\n\tif ( ! source.isObject3D ) {\n\n\t\tsource = getHelperFromSkeleton( source );\n\n\t}\n\n\tconst nameKeys = Object.keys( options.names ),\n\t\tnameValues = Object.values( options.names ),\n\t\tsourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target ),\n\t\toffsets = [];\n\n\tlet bone, boneTo,\n\t\tname, i;\n\n\ttarget.skeleton.pose();\n\n\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\tbone = bones[ i ];\n\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\tboneTo = getBoneByName( name, sourceBones );\n\n\t\tif ( boneTo && name !== options.hip ) {\n\n\t\t\tconst boneParent = getNearestBone( bone.parent, nameKeys ),\n\t\t\t\tboneToParent = getNearestBone( boneTo.parent, nameValues );\n\n\t\t\tboneParent.updateMatrixWorld();\n\t\t\tboneToParent.updateMatrixWorld();\n\n\t\t\ttargetParentPos.setFromMatrixPosition( boneParent.matrixWorld );\n\t\t\ttargetPos.setFromMatrixPosition( bone.matrixWorld );\n\n\t\t\tsourceParentPos.setFromMatrixPosition( boneToParent.matrixWorld );\n\t\t\tsourcePos.setFromMatrixPosition( boneTo.matrixWorld );\n\n\t\t\ttargetDir.subVectors(\n\t\t\t\tnew Vector2( targetPos.x, targetPos.y ),\n\t\t\t\tnew Vector2( targetParentPos.x, targetParentPos.y )\n\t\t\t).normalize();\n\n\t\t\tsourceDir.subVectors(\n\t\t\t\tnew Vector2( sourcePos.x, sourcePos.y ),\n\t\t\t\tnew Vector2( sourceParentPos.x, sourceParentPos.y )\n\t\t\t).normalize();\n\n\t\t\tconst laterialAngle = targetDir.angle() - sourceDir.angle();\n\n\t\t\tconst offset = new Matrix4().makeRotationFromEuler(\n\t\t\t\tnew Euler(\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tlaterialAngle\n\t\t\t\t)\n\t\t\t);\n\n\t\t\tbone.matrix.multiply( offset );\n\n\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\tbone.updateMatrixWorld();\n\n\t\t\toffsets[ name ] = offset;\n\n\t\t}\n\n\t}\n\n\treturn offsets;\n\n}\n\nfunction renameBones( skeleton, names ) {\n\n\tconst bones = getBones( skeleton );\n\n\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\tconst bone = bones[ i ];\n\n\t\tif ( names[ bone.name ] ) {\n\n\t\t\tbone.name = names[ bone.name ];\n\n\t\t}\n\n\t}\n\n\treturn this;\n\n}\n\nfunction getBones( skeleton ) {\n\n\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\n\n}\n\nfunction getBoneByName( name, skeleton ) {\n\n\tfor ( let i = 0, bones = getBones( skeleton ); i < bones.length; i ++ ) {\n\n\t\tif ( name === bones[ i ].name )\n\n\t\t\treturn bones[ i ];\n\n\t}\n\n}\n\nfunction getNearestBone( bone, names ) {\n\n\twhile ( bone.isBone ) {\n\n\t\tif ( names.indexOf( bone.name ) !== - 1 ) {\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t\tbone = bone.parent;\n\n\t}\n\n}\n\nfunction findBoneTrackData( name, tracks ) {\n\n\tconst regexp = /\\[(.*)\\]\\.(.*)/,\n\t\tresult = { name: name };\n\n\tfor ( let i = 0; i < tracks.length; ++ i ) {\n\n\t\t// 1 is track name\n\t\t// 2 is track type\n\t\tconst trackData = regexp.exec( tracks[ i ].name );\n\n\t\tif ( trackData && name === trackData[ 1 ] ) {\n\n\t\t\tresult[ trackData[ 2 ] ] = i;\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\nfunction getEqualsBonesNames( skeleton, targetSkeleton ) {\n\n\tconst sourceBones = getBones( skeleton ),\n\t\ttargetBones = getBones( targetSkeleton ),\n\t\tbones = [];\n\n\tsearch : for ( let i = 0; i < sourceBones.length; i ++ ) {\n\n\t\tconst boneName = sourceBones[ i ].name;\n\n\t\tfor ( let j = 0; j < targetBones.length; j ++ ) {\n\n\t\t\tif ( boneName === targetBones[ j ].name ) {\n\n\t\t\t\tbones.push( boneName );\n\n\t\t\t\tcontinue search;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn bones;\n\n}\n\nfunction clone( source ) {\n\n\tconst sourceLookup = new Map();\n\tconst cloneLookup = new Map();\n\n\tconst clone = source.clone();\n\n\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\n\n\t\tsourceLookup.set( clonedNode, sourceNode );\n\t\tcloneLookup.set( sourceNode, clonedNode );\n\n\t} );\n\n\tclone.traverse( function ( node ) {\n\n\t\tif ( ! node.isSkinnedMesh ) return;\n\n\t\tconst clonedMesh = node;\n\t\tconst sourceMesh = sourceLookup.get( node );\n\t\tconst sourceBones = sourceMesh.skeleton.bones;\n\n\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\n\n\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\n\n\t\t\treturn cloneLookup.get( bone );\n\n\t\t} );\n\n\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\n\n\t} );\n\n\treturn clone;\n\n}\n\n\n\n\nfunction parallelTraverse( a, b, callback ) {\n\n\tcallback( a, b );\n\n\tfor ( let i = 0; i < a.children.length; i ++ ) {\n\n\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\n\n\t}\n\n}\n\nexport {\n\tretarget,\n\tretargetClip,\n\tgetHelperFromSkeleton,\n\tgetSkeletonOffsets,\n\trenameBones,\n\tgetBones,\n\tgetBoneByName,\n\tgetNearestBone,\n\tfindBoneTrackData,\n\tgetEqualsBonesNames,\n\tclone,\n};\n","import { useEffect } from \"react\"\nimport { Canvas, useFrame } from \"@react-three/fiber\"\nimport { useGLTF } from \"@react-three/drei\"\nimport { AnimationMixer } from \"three\"\nimport * as SkeletonUtils from \"three/examples/jsm/utils/SkeletonUtils\"\n\nconst modelPath = `${process.env.PUBLIC_URL}/models/Soldier.glb`\nuseGLTF.preload(modelPath)\n\nconst mixers: AnimationMixer[] = []\n\nconst Model = () => {\n  const { scene, animations } = useGLTF(modelPath)\n\n  const model1 = SkeletonUtils.clone(scene)\n  const model2 = SkeletonUtils.clone(scene)\n  const model3 = SkeletonUtils.clone(scene)\n\n  const mixer1 = new AnimationMixer(model1)\n  const mixer2 = new AnimationMixer(model2)\n  const mixer3 = new AnimationMixer(model3)\n\n  mixer1.clipAction(animations[0]).play()\n  mixer2.clipAction(animations[1]).play()\n  mixer3.clipAction(animations[3]).play()\n\n  model1.position.x = -2\n  model3.position.x = 2\n\n  mixers.push(mixer1, mixer2, mixer3)\n\n  useEffect(() => {\n    scene.traverse((object: any) => object.isMesh && (object.castShadow = true))\n  }, [scene])\n\n  useFrame((_ ,delta) => {\n    mixers.forEach(mixer => mixer.update(delta))\n  })\n\n  return (\n    <>\n      <primitive object={model1} />\n      <primitive object={model2} />\n      <primitive object={model3} />\n    </>\n  )\n}\n\nconst Ground = () => {\n  return (\n    <mesh rotation={[-Math.PI/2, 0, 0]} receiveShadow>\n      <planeGeometry args={[200, 200]} />\n      <meshPhongMaterial color={0x999999} depthWrite={false} />\n    </mesh>\n  )\n}\n\nconst Example = () => {\n  return (\n    <Canvas\n      camera={{ position: [2, 3, -6], fov: 45, near: 1, far: 1000}}\n      dpr={[1, 2]} shadows\n      onCreated={({ camera }) => camera.lookAt(0, 1, 0)}\n    >\n      <color attach=\"background\" args={[0xa0a0a0]} />\n      <fog attach=\"fog\" args={[0xa0a0a0, 10, 50]} />\n      <hemisphereLight position={[0, 20, 0]} args={[0xffffff, 0x444444]} />\n      <directionalLight position={[-3, 10, -10]} args={[0xffffff]} castShadow\n        shadow-camera-top={4} shadow-camera-bottom={-4} shadow-camera-left={-4} shadow-camera-right={4}\n        shadow-camera-near={0.1} shadow-camera-far={40} />\n      <Ground />\n      <Model />\n    </Canvas>\n  )\n}\n\nexport default Example"],"names":["clone","source","sourceLookup","Map","cloneLookup","parallelTraverse","sourceNode","clonedNode","set","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","sourceBones","skeleton","bones","bindMatrix","copy","map","bone","bind","a","b","callback","i","children","length","modelPath","process","useGLTF","mixers","Model","scene","animations","model1","SkeletonUtils","model2","model3","mixer1","AnimationMixer","mixer2","mixer3","clipAction","play","position","x","push","useEffect","object","isMesh","castShadow","useFrame","_","delta","forEach","mixer","update","Ground","rotation","Math","PI","receiveShadow","args","color","depthWrite","camera","fov","near","far","dpr","shadows","onCreated","lookAt","attach"],"sourceRoot":""}