{"version":3,"file":"static/js/567.718c4500.chunk.js","mappings":"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","sources":["contants.tsx","../node_modules/three-stdlib/geometries/DecalGeometry.js","webgl/decals/Example.tsx"],"sourcesContent":["export const canvas_width = window.innerWidth > 640 ? (window.innerWidth - 300) : window.innerWidth\nexport const canvas_height = window.innerWidth > 640 ? window.innerHeight : (window.innerHeight - 48)\n\nexport const aspect_ratio = canvas_width / canvas_height","import { BufferGeometry, Vector3, Matrix4, Float32BufferAttribute } from 'three';\n\n/**\n * You can use this geometry to create a decal mesh, that serves different kinds of purposes.\n * e.g. adding unique details to models, performing dynamic visual environmental changes or covering seams.\n *\n * Constructor parameter:\n *\n * mesh — Any mesh object\n * position — Position of the decal projector\n * orientation — Orientation of the decal projector\n * size — Size of the decal projector\n *\n * reference: http://blog.wolfire.com/2009/06/how-to-project-decals/\n *\n */\n\nclass DecalGeometry extends BufferGeometry {\n  constructor(mesh, position, orientation, size) {\n    super(); // buffers\n\n    const vertices = [];\n    const normals = [];\n    const uvs = []; // helpers\n\n    const plane = new Vector3(); // this matrix represents the transformation of the decal projector\n\n    const projectorMatrix = new Matrix4();\n    projectorMatrix.makeRotationFromEuler(orientation);\n    projectorMatrix.setPosition(position);\n    const projectorMatrixInverse = new Matrix4();\n    projectorMatrixInverse.copy(projectorMatrix).invert(); // generate buffers\n\n    generate(); // build geometry\n\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    function generate() {\n      let i;\n      let decalVertices = [];\n      const vertex = new Vector3();\n      const normal = new Vector3(); // handle different geometry types\n\n      if (mesh.geometry.isGeometry === true) {\n        console.error('THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.');\n        return;\n      }\n\n      const geometry = mesh.geometry;\n      const positionAttribute = geometry.attributes.position;\n      const normalAttribute = geometry.attributes.normal; // first, create an array of 'DecalVertex' objects\n      // three consecutive 'DecalVertex' objects represent a single face\n      //\n      // this data structure will be later used to perform the clipping\n\n      if (geometry.index !== null) {\n        // indexed BufferGeometry\n        const index = geometry.index;\n\n        for (i = 0; i < index.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, index.getX(i));\n          normal.fromBufferAttribute(normalAttribute, index.getX(i));\n          pushDecalVertex(decalVertices, vertex, normal);\n        }\n      } else {\n        // non-indexed BufferGeometry\n        for (i = 0; i < positionAttribute.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, i);\n          normal.fromBufferAttribute(normalAttribute, i);\n          pushDecalVertex(decalVertices, vertex, normal);\n        }\n      } // second, clip the geometry so that it doesn't extend out from the projector\n\n\n      decalVertices = clipGeometry(decalVertices, plane.set(1, 0, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(-1, 0, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 1, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, -1, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, 1));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, -1)); // third, generate final vertices, normals and uvs\n\n      for (i = 0; i < decalVertices.length; i++) {\n        const decalVertex = decalVertices[i]; // create texture coordinates (we are still in projector space)\n\n        uvs.push(0.5 + decalVertex.position.x / size.x, 0.5 + decalVertex.position.y / size.y); // transform the vertex back to world space\n\n        decalVertex.position.applyMatrix4(projectorMatrix); // now create vertex and normal buffer data\n\n        vertices.push(decalVertex.position.x, decalVertex.position.y, decalVertex.position.z);\n        normals.push(decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z);\n      }\n    }\n\n    function pushDecalVertex(decalVertices, vertex, normal) {\n      // transform the vertex to world space, then to projector space\n      vertex.applyMatrix4(mesh.matrixWorld);\n      vertex.applyMatrix4(projectorMatrixInverse);\n      normal.transformDirection(mesh.matrixWorld);\n      decalVertices.push(new DecalVertex(vertex.clone(), normal.clone()));\n    }\n\n    function clipGeometry(inVertices, plane) {\n      const outVertices = [];\n      const s = 0.5 * Math.abs(size.dot(plane)); // a single iteration clips one face,\n      // which consists of three consecutive 'DecalVertex' objects\n\n      for (let i = 0; i < inVertices.length; i += 3) {\n        let v1Out,\n            v2Out,\n            v3Out,\n            total = 0;\n        let nV1, nV2, nV3, nV4;\n        const d1 = inVertices[i + 0].position.dot(plane) - s;\n        const d2 = inVertices[i + 1].position.dot(plane) - s;\n        const d3 = inVertices[i + 2].position.dot(plane) - s;\n        v1Out = d1 > 0;\n        v2Out = d2 > 0;\n        v3Out = d3 > 0; // calculate, how many vertices of the face lie outside of the clipping plane\n\n        total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\n\n        switch (total) {\n          case 0:\n            {\n              // the entire face lies inside of the plane, no clipping needed\n              outVertices.push(inVertices[i]);\n              outVertices.push(inVertices[i + 1]);\n              outVertices.push(inVertices[i + 2]);\n              break;\n            }\n\n          case 1:\n            {\n              // one vertex lies outside of the plane, perform clipping\n              if (v1Out) {\n                nV1 = inVertices[i + 1];\n                nV2 = inVertices[i + 2];\n                nV3 = clip(inVertices[i], nV1, plane, s);\n                nV4 = clip(inVertices[i], nV2, plane, s);\n              }\n\n              if (v2Out) {\n                nV1 = inVertices[i];\n                nV2 = inVertices[i + 2];\n                nV3 = clip(inVertices[i + 1], nV1, plane, s);\n                nV4 = clip(inVertices[i + 1], nV2, plane, s);\n                outVertices.push(nV3);\n                outVertices.push(nV2.clone());\n                outVertices.push(nV1.clone());\n                outVertices.push(nV2.clone());\n                outVertices.push(nV3.clone());\n                outVertices.push(nV4);\n                break;\n              }\n\n              if (v3Out) {\n                nV1 = inVertices[i];\n                nV2 = inVertices[i + 1];\n                nV3 = clip(inVertices[i + 2], nV1, plane, s);\n                nV4 = clip(inVertices[i + 2], nV2, plane, s);\n              }\n\n              outVertices.push(nV1.clone());\n              outVertices.push(nV2.clone());\n              outVertices.push(nV3);\n              outVertices.push(nV4);\n              outVertices.push(nV3.clone());\n              outVertices.push(nV2.clone());\n              break;\n            }\n\n          case 2:\n            {\n              // two vertices lies outside of the plane, perform clipping\n              if (!v1Out) {\n                nV1 = inVertices[i].clone();\n                nV2 = clip(nV1, inVertices[i + 1], plane, s);\n                nV3 = clip(nV1, inVertices[i + 2], plane, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n\n              if (!v2Out) {\n                nV1 = inVertices[i + 1].clone();\n                nV2 = clip(nV1, inVertices[i + 2], plane, s);\n                nV3 = clip(nV1, inVertices[i], plane, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n\n              if (!v3Out) {\n                nV1 = inVertices[i + 2].clone();\n                nV2 = clip(nV1, inVertices[i], plane, s);\n                nV3 = clip(nV1, inVertices[i + 1], plane, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n\n              break;\n            }\n        }\n      }\n\n      return outVertices;\n    }\n\n    function clip(v0, v1, p, s) {\n      const d0 = v0.position.dot(p) - s;\n      const d1 = v1.position.dot(p) - s;\n      const s0 = d0 / (d0 - d1);\n      const v = new DecalVertex(new Vector3(v0.position.x + s0 * (v1.position.x - v0.position.x), v0.position.y + s0 * (v1.position.y - v0.position.y), v0.position.z + s0 * (v1.position.z - v0.position.z)), new Vector3(v0.normal.x + s0 * (v1.normal.x - v0.normal.x), v0.normal.y + s0 * (v1.normal.y - v0.normal.y), v0.normal.z + s0 * (v1.normal.z - v0.normal.z))); // need to clip more values (texture coordinates)? do it this way:\n      // intersectpoint.value = a.value + s * ( b.value - a.value );\n\n      return v;\n    }\n  }\n\n} // helper\n\n\nclass DecalVertex {\n  constructor(position, normal) {\n    this.position = position;\n    this.normal = normal;\n  }\n\n  clone() {\n    return new this.constructor(this.position.clone(), this.normal.clone());\n  }\n\n}\n\nexport { DecalGeometry, DecalVertex };\n","import { useState } from 'react'\nimport * as THREE from 'three'\nimport { DecalGeometry } from 'three-stdlib'\nimport { Canvas } from '@react-three/fiber'\nimport { OrbitControls, useGLTF } from '@react-three/drei'\n\nimport { aspect_ratio } from '../../contants'\n\nimport model from '../../models/LeePerrySmith/LeePerrySmith.glb'\nimport map from '../../models/LeePerrySmith/Map-COL.jpg'\nimport specularMap from '../../models/LeePerrySmith/Map-SPEC.jpg'\nimport normalMap from '../../models/LeePerrySmith/Infinite-Level_02_Tangent_SmoothUV.jpg'\n\nimport decal_diffuse from '../../textures/decal/decal-diffuse.png'\nimport decal_normal from '../../textures/decal/decal-normal.jpg'\n\nuseGLTF.preload(model)\n\nconst textureLoader = new THREE.TextureLoader()\nconst mapTexture = textureLoader.load(map)\nconst specularMapTexture = textureLoader.load(specularMap)\nconst normalMapTexture = textureLoader.load(normalMap)\n\n// const decals: any[] = []\nconst params = {\n  minScale: 10,\n  maxScale: 20,\n  rotate: true,\n  clear: () => {\n    // removeDecals()\n  }\n}\n\nconst decalDiffuse = textureLoader.load(decal_diffuse)\nconst decalNormal = textureLoader.load(decal_normal)\nconst decalMaterial = new THREE.MeshPhongMaterial({\n  specular: 0x444444,\n  map: decalDiffuse,\n  normalMap: decalNormal,\n  normalScale: new THREE.Vector2(1, 1),\n  shininess: 30,\n  transparent: true,\n  depthTest: true,\n  depthWrite: false,\n  polygonOffset: true,\n  polygonOffsetFactor: -4,\n  wireframe: false\n})\n\n// const createControls = () => {\n//   const gui = new GUI()\n\n//   gui.add(params, 'minScale', 1, 30)\n//   gui.add(params, 'maxScale', 1, 30)\n//   gui.add(params, 'rotate')\n//   gui.add(params, 'clear')\n//   gui.open()\n// }\n\n// const removeDecals = () => {\n//   decals.forEach(d => {\n//     scene.remove(d)\n//   })\n//   decals.length = 0\n// }\n\nconst Model = () => {\n  const { scene }: any = useGLTF(model)\n  const mesh = scene.children[0]\n\n  const [decals, setDecals] = useState<any[]>([])\n\n  const shoot = (event: any) => {\n    const position = event.point\n    const size = new THREE.Vector3(10, 10, 10)\n    const scale = params.minScale + Math.random() * (params.maxScale - params.minScale)\n    size.set(scale, scale, scale)\n    const material = decalMaterial.clone()\n    material.color.setHex(Math.random() * 0xffffff)\n\n    const m = new THREE.Mesh(new DecalGeometry(mesh, position, new THREE.Euler(), size), material)\n    setDecals(decals => [m, ...decals])\n  }\n\n  return (\n    <>\n      <primitive object={mesh} scale={10} onClick={shoot}>\n        <meshPhongMaterial attach='material' specular={0x111111} shininess={25}\n          map={mapTexture}\n          specularMap={specularMapTexture}\n          normalMap={normalMapTexture}\n        />\n      </primitive>\n      {\n        decals.map((d, i) => (\n          <primitive key={i} object={d} />\n        ))\n      }\n    </>\n  )\n}\n\nconst Example = () => {  \n  return (\n    <Canvas camera={{position: [0, 0, 120], fov: 45, aspect: aspect_ratio, near: 1, far: 1000 }} >\n      <color attach='background' args={['black']} />\n      <ambientLight args={[0x443333]} />\n      <directionalLight args={[0xffddcc, 1]} position={[1, 0.75, 0.5]} />\n      <directionalLight args={[0xccccff, 1]} position={[-1, 0.75, -0.5]} />\n      <Model />\n      <OrbitControls \n        minDistance={50}\n        maxDistance={200}\n      />\n    </Canvas>\n  )\n}\n\nexport default Example"],"names":["canvas_width","window","innerWidth","canvas_height","innerHeight","aspect_ratio","DecalGeometry","mesh","position","orientation","size","vertices","normals","uvs","plane","Vector3","projectorMatrix","Matrix4","makeRotationFromEuler","setPosition","projectorMatrixInverse","pushDecalVertex","decalVertices","vertex","normal","applyMatrix4","matrixWorld","transformDirection","push","DecalVertex","clone","clipGeometry","inVertices","outVertices","s","Math","abs","dot","i","length","v1Out","v2Out","v3Out","nV1","nV2","nV3","nV4","clip","v0","v1","p","d0","s0","x","y","z","copy","invert","geometry","isGeometry","console","error","positionAttribute","attributes","normalAttribute","index","count","fromBufferAttribute","getX","set","decalVertex","generate","setAttribute","Float32BufferAttribute","BufferGeometry","this","constructor","useGLTF","model","textureLoader","THREE","mapTexture","load","map","specularMapTexture","specularMap","normalMapTexture","normalMap","params","decalDiffuse","decal_diffuse","decalNormal","decal_normal","decalMaterial","specular","normalScale","shininess","transparent","depthTest","depthWrite","polygonOffset","polygonOffsetFactor","wireframe","Model","scene","children","useState","decals","setDecals","object","scale","onClick","event","point","random","material","color","setHex","m","attach","d","camera","fov","aspect","near","far","args","OrbitControls","minDistance","maxDistance"],"sourceRoot":""}