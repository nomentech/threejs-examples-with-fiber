{"version":3,"file":"static/js/963.58a4f2c6.chunk.js","mappings":"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","sources":["../node_modules/@react-three/drei/core/useTexture.js","../node_modules/three/examples/jsm/math/ConvexHull.js","../node_modules/three/examples/jsm/geometries/ConvexGeometry.js","../node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"],"sourcesContent":["import { TextureLoader } from 'three';\nimport { useThree, useLoader } from '@react-three/fiber';\nimport { useEffect } from 'react';\n\nconst IsObject = url => url === Object(url) && !Array.isArray(url) && typeof url !== 'function';\nfunction useTexture(input) {\n  const gl = useThree(state => state.gl);\n  const textures = useLoader(TextureLoader, IsObject(input) ? Object.values(input) : input); // https://github.com/mrdoob/three.js/issues/22696\n  // Upload the texture to the GPU immediately instead of waiting for the first render\n\n  useEffect(() => {\n    const array = Array.isArray(textures) ? textures : [textures];\n    array.forEach(gl.initTexture);\n  }, [gl, textures]);\n\n  if (IsObject(input)) {\n    const keys = Object.keys(input);\n    const keyed = {};\n    keys.forEach(key => Object.assign(keyed, {\n      [key]: textures[keys.indexOf(key)]\n    }));\n    return keyed;\n  } else {\n    return textures;\n  }\n}\n\nuseTexture.preload = url => useLoader.preload(TextureLoader, url);\n\nuseTexture.clear = input => useLoader.clear(TextureLoader, input);\n\nexport { IsObject, useTexture };\n","import {\n\tLine3,\n\tPlane,\n\tTriangle,\n\tVector3\n} from 'three';\n\n/**\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n */\n\nconst Visible = 0;\nconst Deleted = 1;\n\nconst _v1 = new Vector3();\nconst _line3 = new Line3();\nconst _plane = new Plane();\nconst _closestPoint = new Vector3();\nconst _triangle = new Triangle();\n\nclass ConvexHull {\n\n\tconstructor() {\n\n\t\tthis.tolerance = - 1;\n\n\t\tthis.faces = []; // the generated faces of the convex hull\n\t\tthis.newFaces = []; // this array holds the faces that are generated within a single iteration\n\n\t\t// the vertex lists work as follows:\n\t\t//\n\t\t// let 'a' and 'b' be 'Face' instances\n\t\t// let 'v' be points wrapped as instance of 'Vertex'\n\t\t//\n\t\t//     [v, v, ..., v, v, v, ...]\n\t\t//      ^             ^\n\t\t//      |             |\n\t\t//  a.outside     b.outside\n\t\t//\n\t\tthis.assigned = new VertexList();\n\t\tthis.unassigned = new VertexList();\n\n\t\tthis.vertices = []; \t// vertices of the hull (internal representation of given geometry data)\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\t// The algorithm needs at least four points.\n\n\t\tif ( points.length >= 4 ) {\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tthis.vertices.push( new VertexNode( points[ i ] ) );\n\n\t\t\t}\n\n\t\t\tthis.compute();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromObject( object ) {\n\n\t\tconst points = [];\n\n\t\tobject.updateMatrixWorld( true );\n\n\t\tobject.traverse( function ( node ) {\n\n\t\t\tconst geometry = node.geometry;\n\n\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\tif ( geometry.isGeometry ) {\n\n\t\t\t\t\tconsole.error( 'THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t} else if ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\tconst attribute = geometry.attributes.position;\n\n\t\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\t\tfor ( let i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst point = new Vector3();\n\n\t\t\t\t\t\t\tpoint.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tpoints.push( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn this.setFromPoints( points );\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\tconst faces = this.faces;\n\n\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\n\t\t\t// compute signed distance and check on what half space the point lies\n\n\t\t\tif ( face.distanceToPoint( point ) > this.tolerance ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tintersectRay( ray, target ) {\n\n\t\t// based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\n\n\t\tconst faces = this.faces;\n\n\t\tlet tNear = - Infinity;\n\t\tlet tFar = Infinity;\n\n\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\n\t\t\t// interpret faces as planes for the further computation\n\n\t\t\tconst vN = face.distanceToPoint( ray.origin );\n\t\t\tconst vD = face.normal.dot( ray.direction );\n\n\t\t\t// if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n\t\t\t// the ray is turned away or parallel to the plane, there is no intersection\n\n\t\t\tif ( vN > 0 && vD >= 0 ) return null;\n\n\t\t\t// compute the distance from the rayâ€™s origin to the intersection with the plane\n\n\t\t\tconst t = ( vD !== 0 ) ? ( - vN / vD ) : 0;\n\n\t\t\t// only proceed if the distance is positive. a negative distance means the intersection point\n\t\t\t// lies \"behind\" the origin\n\n\t\t\tif ( t <= 0 ) continue;\n\n\t\t\t// now categorized plane as front-facing or back-facing\n\n\t\t\tif ( vD > 0 ) {\n\n\t\t\t\t//  plane faces away from the ray, so this plane is a back-face\n\n\t\t\t\ttFar = Math.min( t, tFar );\n\n\t\t\t} else {\n\n\t\t\t\t// front-face\n\n\t\t\t\ttNear = Math.max( t, tNear );\n\n\t\t\t}\n\n\t\t\tif ( tNear > tFar ) {\n\n\t\t\t\t// if tNear ever is greater than tFar, the ray must miss the convex hull\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// evaluate intersection point\n\n\t\t// always try tNear first since its the closer intersection point\n\n\t\tif ( tNear !== - Infinity ) {\n\n\t\t\tray.at( tNear, target );\n\n\t\t} else {\n\n\t\t\tray.at( tFar, target );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tintersectsRay( ray ) {\n\n\t\treturn this.intersectRay( ray, _v1 ) !== null;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.faces = [];\n\t\tthis.vertices = [];\n\n\t\treturn this;\n\n\t}\n\n\t// Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n\taddVertexToFace( vertex, face ) {\n\n\t\tvertex.face = face;\n\n\t\tif ( face.outside === null ) {\n\n\t\t\tthis.assigned.append( vertex );\n\n\t\t} else {\n\n\t\t\tthis.assigned.insertBefore( face.outside, vertex );\n\n\t\t}\n\n\t\tface.outside = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t// Removes a vertex from the 'assigned' list of vertices and from the given face\n\n\tremoveVertexFromFace( vertex, face ) {\n\n\t\tif ( vertex === face.outside ) {\n\n\t\t\t// fix face.outside link\n\n\t\t\tif ( vertex.next !== null && vertex.next.face === face ) {\n\n\t\t\t\t// face has at least 2 outside vertices, move the 'outside' reference\n\n\t\t\t\tface.outside = vertex.next;\n\n\t\t\t} else {\n\n\t\t\t\t// vertex was the only outside vertex that face had\n\n\t\t\t\tface.outside = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.assigned.remove( vertex );\n\n\t\treturn this;\n\n\t}\n\n\t// Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n\n\tremoveAllVerticesFromFace( face ) {\n\n\t\tif ( face.outside !== null ) {\n\n\t\t\t// reference to the first and last vertex of this face\n\n\t\t\tconst start = face.outside;\n\t\t\tlet end = face.outside;\n\n\t\t\twhile ( end.next !== null && end.next.face === face ) {\n\n\t\t\t\tend = end.next;\n\n\t\t\t}\n\n\t\t\tthis.assigned.removeSubList( start, end );\n\n\t\t\t// fix references\n\n\t\t\tstart.prev = end.next = null;\n\t\t\tface.outside = null;\n\n\t\t\treturn start;\n\n\t\t}\n\n\t}\n\n\t// Removes all the visible vertices that 'face' is able to see\n\n\tdeleteFaceVertices( face, absorbingFace ) {\n\n\t\tconst faceVertices = this.removeAllVerticesFromFace( face );\n\n\t\tif ( faceVertices !== undefined ) {\n\n\t\t\tif ( absorbingFace === undefined ) {\n\n\t\t\t\t// mark the vertices to be reassigned to some other face\n\n\t\t\t\tthis.unassigned.appendChain( faceVertices );\n\n\n\t\t\t} else {\n\n\t\t\t\t// if there's an absorbing face try to assign as many vertices as possible to it\n\n\t\t\t\tlet vertex = faceVertices;\n\n\t\t\t\tdo {\n\n\t\t\t\t\t// we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n\t\t\t\t\t// will be changed by upcoming method calls\n\n\t\t\t\t\tconst nextVertex = vertex.next;\n\n\t\t\t\t\tconst distance = absorbingFace.distanceToPoint( vertex.point );\n\n\t\t\t\t\t// check if 'vertex' is able to see 'absorbingFace'\n\n\t\t\t\t\tif ( distance > this.tolerance ) {\n\n\t\t\t\t\t\tthis.addVertexToFace( vertex, absorbingFace );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.unassigned.append( vertex );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// now assign next vertex\n\n\t\t\t\t\tvertex = nextVertex;\n\n\t\t\t\t} while ( vertex !== null );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Reassigns as many vertices as possible from the unassigned list to the new faces\n\n\tresolveUnassignedPoints( newFaces ) {\n\n\t\tif ( this.unassigned.isEmpty() === false ) {\n\n\t\t\tlet vertex = this.unassigned.first();\n\n\t\t\tdo {\n\n\t\t\t\t// buffer 'next' reference, see .deleteFaceVertices()\n\n\t\t\t\tconst nextVertex = vertex.next;\n\n\t\t\t\tlet maxDistance = this.tolerance;\n\n\t\t\t\tlet maxFace = null;\n\n\t\t\t\tfor ( let i = 0; i < newFaces.length; i ++ ) {\n\n\t\t\t\t\tconst face = newFaces[ i ];\n\n\t\t\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\t\t\tconst distance = face.distanceToPoint( vertex.point );\n\n\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\tmaxFace = face;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( maxDistance > 1000 * this.tolerance ) break;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// 'maxFace' can be null e.g. if there are identical vertices\n\n\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\n\n\t\t\t\t}\n\n\t\t\t\tvertex = nextVertex;\n\n\t\t\t} while ( vertex !== null );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Computes the extremes of a simplex which will be the initial hull\n\n\tcomputeExtremes() {\n\n\t\tconst min = new Vector3();\n\t\tconst max = new Vector3();\n\n\t\tconst minVertices = [];\n\t\tconst maxVertices = [];\n\n\t\t// initially assume that the first vertex is the min/max\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tminVertices[ i ] = maxVertices[ i ] = this.vertices[ 0 ];\n\n\t\t}\n\n\t\tmin.copy( this.vertices[ 0 ].point );\n\t\tmax.copy( this.vertices[ 0 ].point );\n\n\t\t// compute the min/max vertex on all six directions\n\n\t\tfor ( let i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = this.vertices[ i ];\n\t\t\tconst point = vertex.point;\n\n\t\t\t// update the min coordinates\n\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\tif ( point.getComponent( j ) < min.getComponent( j ) ) {\n\n\t\t\t\t\tmin.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\tminVertices[ j ] = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the max coordinates\n\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\tif ( point.getComponent( j ) > max.getComponent( j ) ) {\n\n\t\t\t\t\tmax.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\tmaxVertices[ j ] = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use min/max vectors to compute an optimal epsilon\n\n\t\tthis.tolerance = 3 * Number.EPSILON * (\n\t\t\tMath.max( Math.abs( min.x ), Math.abs( max.x ) ) +\n\t\t\tMath.max( Math.abs( min.y ), Math.abs( max.y ) ) +\n\t\t\tMath.max( Math.abs( min.z ), Math.abs( max.z ) )\n\t\t);\n\n\t\treturn { min: minVertices, max: maxVertices };\n\n\t}\n\n\t// Computes the initial simplex assigning to its faces all the points\n\t// that are candidates to form part of the hull\n\n\tcomputeInitialHull() {\n\n\t\tconst vertices = this.vertices;\n\t\tconst extremes = this.computeExtremes();\n\t\tconst min = extremes.min;\n\t\tconst max = extremes.max;\n\n\t\t// 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n\t\t// (max.x - min.x)\n\t\t// (max.y - min.y)\n\t\t// (max.z - min.z)\n\n\t\tlet maxDistance = 0;\n\t\tlet index = 0;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst distance = max[ i ].point.getComponent( i ) - min[ i ].point.getComponent( i );\n\n\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\tmaxDistance = distance;\n\t\t\t\tindex = i;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst v0 = min[ index ];\n\t\tconst v1 = max[ index ];\n\t\tlet v2;\n\t\tlet v3;\n\n\t\t// 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n\t\tmaxDistance = 0;\n\t\t_line3.set( v0.point, v1.point );\n\n\t\tfor ( let i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ];\n\n\t\t\tif ( vertex !== v0 && vertex !== v1 ) {\n\n\t\t\t\t_line3.closestPointToPoint( vertex.point, true, _closestPoint );\n\n\t\t\t\tconst distance = _closestPoint.distanceToSquared( vertex.point );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\tv2 = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\t\tmaxDistance = - 1;\n\t\t_plane.setFromCoplanarPoints( v0.point, v1.point, v2.point );\n\n\t\tfor ( let i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ];\n\n\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 ) {\n\n\t\t\t\tconst distance = Math.abs( _plane.distanceToPoint( vertex.point ) );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\tv3 = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst faces = [];\n\n\t\tif ( _plane.distanceToPoint( v3.point ) < 0 ) {\n\n\t\t\t// the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n\n\t\t\tfaces.push(\n\t\t\t\tFace.create( v0, v1, v2 ),\n\t\t\t\tFace.create( v3, v1, v0 ),\n\t\t\t\tFace.create( v3, v2, v1 ),\n\t\t\t\tFace.create( v3, v0, v2 )\n\t\t\t);\n\n\t\t\t// set the twin edge\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst j = ( i + 1 ) % 3;\n\n\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( j ) );\n\n\t\t\t\t// join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 1 ).setTwin( faces[ j + 1 ].getEdge( 0 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n\n\t\t\tfaces.push(\n\t\t\t\tFace.create( v0, v2, v1 ),\n\t\t\t\tFace.create( v3, v0, v1 ),\n\t\t\t\tFace.create( v3, v1, v2 ),\n\t\t\t\tFace.create( v3, v2, v0 )\n\t\t\t);\n\n\t\t\t// set the twin edge\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst j = ( i + 1 ) % 3;\n\n\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( ( 3 - i ) % 3 ) );\n\n\t\t\t\t// join face[ i ] with face[ i + 1 ]\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 0 ).setTwin( faces[ j + 1 ].getEdge( 1 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// the initial hull is the tetrahedron\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ] );\n\n\t\t}\n\n\t\t// initial assignment of vertices to the faces of the tetrahedron\n\n\t\tfor ( let i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ];\n\n\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3 ) {\n\n\t\t\t\tmaxDistance = this.tolerance;\n\t\t\t\tlet maxFace = null;\n\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\tconst distance = this.faces[ j ].distanceToPoint( vertex.point );\n\n\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\tmaxFace = this.faces[ j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Removes inactive faces\n\n\treindexFaces() {\n\n\t\tconst activeFaces = [];\n\n\t\tfor ( let i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\n\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\tactiveFaces.push( face );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.faces = activeFaces;\n\n\t\treturn this;\n\n\t}\n\n\t// Finds the next vertex to create faces with the current hull\n\n\tnextVertexToAdd() {\n\n\t\t// if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n\n\t\tif ( this.assigned.isEmpty() === false ) {\n\n\t\t\tlet eyeVertex, maxDistance = 0;\n\n\t\t\t// grap the first available face and start with the first visible vertex of that face\n\n\t\t\tconst eyeFace = this.assigned.first().face;\n\t\t\tlet vertex = eyeFace.outside;\n\n\t\t\t// now calculate the farthest vertex that face can see\n\n\t\t\tdo {\n\n\t\t\t\tconst distance = eyeFace.distanceToPoint( vertex.point );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\teyeVertex = vertex;\n\n\t\t\t\t}\n\n\t\t\t\tvertex = vertex.next;\n\n\t\t\t} while ( vertex !== null && vertex.face === eyeFace );\n\n\t\t\treturn eyeVertex;\n\n\t\t}\n\n\t}\n\n\t// Computes a chain of half edges in CCW order called the 'horizon'.\n\t// For an edge to be part of the horizon it must join a face that can see\n\t// 'eyePoint' and a face that cannot see 'eyePoint'.\n\n\tcomputeHorizon( eyePoint, crossEdge, face, horizon ) {\n\n\t\t// moves face's vertices to the 'unassigned' vertex list\n\n\t\tthis.deleteFaceVertices( face );\n\n\t\tface.mark = Deleted;\n\n\t\tlet edge;\n\n\t\tif ( crossEdge === null ) {\n\n\t\t\tedge = crossEdge = face.getEdge( 0 );\n\n\t\t} else {\n\n\t\t\t// start from the next edge since 'crossEdge' was already analyzed\n\t\t\t// (actually 'crossEdge.twin' was the edge who called this method recursively)\n\n\t\t\tedge = crossEdge.next;\n\n\t\t}\n\n\t\tdo {\n\n\t\t\tconst twinEdge = edge.twin;\n\t\t\tconst oppositeFace = twinEdge.face;\n\n\t\t\tif ( oppositeFace.mark === Visible ) {\n\n\t\t\t\tif ( oppositeFace.distanceToPoint( eyePoint ) > this.tolerance ) {\n\n\t\t\t\t\t// the opposite face can see the vertex, so proceed with next edge\n\n\t\t\t\t\tthis.computeHorizon( eyePoint, twinEdge, oppositeFace, horizon );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// the opposite face can't see the vertex, so this edge is part of the horizon\n\n\t\t\t\t\thorizon.push( edge );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tedge = edge.next;\n\n\t\t} while ( edge !== crossEdge );\n\n\t\treturn this;\n\n\t}\n\n\t// Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n\taddAdjoiningFace( eyeVertex, horizonEdge ) {\n\n\t\t// all the half edges are created in ccw order thus the face is always pointing outside the hull\n\n\t\tconst face = Face.create( eyeVertex, horizonEdge.tail(), horizonEdge.head() );\n\n\t\tthis.faces.push( face );\n\n\t\t// join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n\t\tface.getEdge( - 1 ).setTwin( horizonEdge.twin );\n\n\t\treturn face.getEdge( 0 ); // the half edge whose vertex is the eyeVertex\n\n\n\t}\n\n\t//  Adds 'horizon.length' faces to the hull, each face will be linked with the\n\t//  horizon opposite face and the face on the left/right\n\n\taddNewFaces( eyeVertex, horizon ) {\n\n\t\tthis.newFaces = [];\n\n\t\tlet firstSideEdge = null;\n\t\tlet previousSideEdge = null;\n\n\t\tfor ( let i = 0; i < horizon.length; i ++ ) {\n\n\t\t\tconst horizonEdge = horizon[ i ];\n\n\t\t\t// returns the right side edge\n\n\t\t\tconst sideEdge = this.addAdjoiningFace( eyeVertex, horizonEdge );\n\n\t\t\tif ( firstSideEdge === null ) {\n\n\t\t\t\tfirstSideEdge = sideEdge;\n\n\t\t\t} else {\n\n\t\t\t\t// joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n\n\t\t\t\tsideEdge.next.setTwin( previousSideEdge );\n\n\t\t\t}\n\n\t\t\tthis.newFaces.push( sideEdge.face );\n\t\t\tpreviousSideEdge = sideEdge;\n\n\t\t}\n\n\t\t// perform final join of new faces\n\n\t\tfirstSideEdge.next.setTwin( previousSideEdge );\n\n\t\treturn this;\n\n\t}\n\n\t// Adds a vertex to the hull\n\n\taddVertexToHull( eyeVertex ) {\n\n\t\tconst horizon = [];\n\n\t\tthis.unassigned.clear();\n\n\t\t// remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n\t\tthis.removeVertexFromFace( eyeVertex, eyeVertex.face );\n\n\t\tthis.computeHorizon( eyeVertex.point, null, eyeVertex.face, horizon );\n\n\t\tthis.addNewFaces( eyeVertex, horizon );\n\n\t\t// reassign 'unassigned' vertices to the new faces\n\n\t\tthis.resolveUnassignedPoints( this.newFaces );\n\n\t\treturn\tthis;\n\n\t}\n\n\tcleanup() {\n\n\t\tthis.assigned.clear();\n\t\tthis.unassigned.clear();\n\t\tthis.newFaces = [];\n\n\t\treturn this;\n\n\t}\n\n\tcompute() {\n\n\t\tlet vertex;\n\n\t\tthis.computeInitialHull();\n\n\t\t// add all available vertices gradually to the hull\n\n\t\twhile ( ( vertex = this.nextVertexToAdd() ) !== undefined ) {\n\n\t\t\tthis.addVertexToHull( vertex );\n\n\t\t}\n\n\t\tthis.reindexFaces();\n\n\t\tthis.cleanup();\n\n\t\treturn this;\n\n\t}\n\n}\n\n//\n\nclass Face {\n\n\tconstructor() {\n\n\t\tthis.normal = new Vector3();\n\t\tthis.midpoint = new Vector3();\n\t\tthis.area = 0;\n\n\t\tthis.constant = 0; // signed distance from face to the origin\n\t\tthis.outside = null; // reference to a vertex in a vertex list this face can see\n\t\tthis.mark = Visible;\n\t\tthis.edge = null;\n\n\t}\n\n\tstatic create( a, b, c ) {\n\n\t\tconst face = new Face();\n\n\t\tconst e0 = new HalfEdge( a, face );\n\t\tconst e1 = new HalfEdge( b, face );\n\t\tconst e2 = new HalfEdge( c, face );\n\n\t\t// join edges\n\n\t\te0.next = e2.prev = e1;\n\t\te1.next = e0.prev = e2;\n\t\te2.next = e1.prev = e0;\n\n\t\t// main half edge reference\n\n\t\tface.edge = e0;\n\n\t\treturn face.compute();\n\n\t}\n\n\tgetEdge( i ) {\n\n\t\tlet edge = this.edge;\n\n\t\twhile ( i > 0 ) {\n\n\t\t\tedge = edge.next;\n\t\t\ti --;\n\n\t\t}\n\n\t\twhile ( i < 0 ) {\n\n\t\t\tedge = edge.prev;\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn edge;\n\n\t}\n\n\tcompute() {\n\n\t\tconst a = this.edge.tail();\n\t\tconst b = this.edge.head();\n\t\tconst c = this.edge.next.head();\n\n\t\t_triangle.set( a.point, b.point, c.point );\n\n\t\t_triangle.getNormal( this.normal );\n\t\t_triangle.getMidpoint( this.midpoint );\n\t\tthis.area = _triangle.getArea();\n\n\t\tthis.constant = this.normal.dot( this.midpoint );\n\n\t\treturn this;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.normal.dot( point ) - this.constant;\n\n\t}\n\n}\n\n// Entity for a Doubly-Connected Edge List (DCEL).\n\nclass HalfEdge {\n\n\n\tconstructor( vertex, face ) {\n\n\t\tthis.vertex = vertex;\n\t\tthis.prev = null;\n\t\tthis.next = null;\n\t\tthis.twin = null;\n\t\tthis.face = face;\n\n\t}\n\n\thead() {\n\n\t\treturn this.vertex;\n\n\t}\n\n\ttail() {\n\n\t\treturn this.prev ? this.prev.vertex : null;\n\n\t}\n\n\tlength() {\n\n\t\tconst head = this.head();\n\t\tconst tail = this.tail();\n\n\t\tif ( tail !== null ) {\n\n\t\t\treturn tail.point.distanceTo( head.point );\n\n\t\t}\n\n\t\treturn - 1;\n\n\t}\n\n\tlengthSquared() {\n\n\t\tconst head = this.head();\n\t\tconst tail = this.tail();\n\n\t\tif ( tail !== null ) {\n\n\t\t\treturn tail.point.distanceToSquared( head.point );\n\n\t\t}\n\n\t\treturn - 1;\n\n\t}\n\n\tsetTwin( edge ) {\n\n\t\tthis.twin = edge;\n\t\tedge.twin = this;\n\n\t\treturn this;\n\n\t}\n\n}\n\n// A vertex as a double linked list node.\n\nclass VertexNode {\n\n\tconstructor( point ) {\n\n\t\tthis.point = point;\n\t\tthis.prev = null;\n\t\tthis.next = null;\n\t\tthis.face = null; // the face that is able to see this vertex\n\n\t}\n\n}\n\n// A double linked list that contains vertex nodes.\n\nclass VertexList {\n\n\tconstructor() {\n\n\t\tthis.head = null;\n\t\tthis.tail = null;\n\n\t}\n\n\tfirst() {\n\n\t\treturn this.head;\n\n\t}\n\n\tlast() {\n\n\t\treturn this.tail;\n\n\t}\n\n\tclear() {\n\n\t\tthis.head = this.tail = null;\n\n\t\treturn this;\n\n\t}\n\n\t// Inserts a vertex before the target vertex\n\n\tinsertBefore( target, vertex ) {\n\n\t\tvertex.prev = target.prev;\n\t\tvertex.next = target;\n\n\t\tif ( vertex.prev === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tvertex.prev.next = vertex;\n\n\t\t}\n\n\t\ttarget.prev = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t// Inserts a vertex after the target vertex\n\n\tinsertAfter( target, vertex ) {\n\n\t\tvertex.prev = target;\n\t\tvertex.next = target.next;\n\n\t\tif ( vertex.next === null ) {\n\n\t\t\tthis.tail = vertex;\n\n\t\t} else {\n\n\t\t\tvertex.next.prev = vertex;\n\n\t\t}\n\n\t\ttarget.next = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t// Appends a vertex to the end of the linked list\n\n\tappend( vertex ) {\n\n\t\tif ( this.head === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tthis.tail.next = vertex;\n\n\t\t}\n\n\t\tvertex.prev = this.tail;\n\t\tvertex.next = null; // the tail has no subsequent vertex\n\n\t\tthis.tail = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t// Appends a chain of vertices where 'vertex' is the head.\n\n\tappendChain( vertex ) {\n\n\t\tif ( this.head === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tthis.tail.next = vertex;\n\n\t\t}\n\n\t\tvertex.prev = this.tail;\n\n\t\t// ensure that the 'tail' reference points to the last vertex of the chain\n\n\t\twhile ( vertex.next !== null ) {\n\n\t\t\tvertex = vertex.next;\n\n\t\t}\n\n\t\tthis.tail = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t// Removes a vertex from the linked list\n\n\tremove( vertex ) {\n\n\t\tif ( vertex.prev === null ) {\n\n\t\t\tthis.head = vertex.next;\n\n\t\t} else {\n\n\t\t\tvertex.prev.next = vertex.next;\n\n\t\t}\n\n\t\tif ( vertex.next === null ) {\n\n\t\t\tthis.tail = vertex.prev;\n\n\t\t} else {\n\n\t\t\tvertex.next.prev = vertex.prev;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n\tremoveSubList( a, b ) {\n\n\t\tif ( a.prev === null ) {\n\n\t\t\tthis.head = b.next;\n\n\t\t} else {\n\n\t\t\ta.prev.next = b.next;\n\n\t\t}\n\n\t\tif ( b.next === null ) {\n\n\t\t\tthis.tail = a.prev;\n\n\t\t} else {\n\n\t\t\tb.next.prev = a.prev;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\treturn this.head === null;\n\n\t}\n\n}\n\nexport { ConvexHull };\n","import {\n\tBufferGeometry,\n\tFloat32BufferAttribute\n} from 'three';\nimport { ConvexHull } from '../math/ConvexHull.js';\n\nclass ConvexGeometry extends BufferGeometry {\n\n\tconstructor( points = [] ) {\n\n\t\tsuper();\n\n\t\t// buffers\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\n\t\tif ( ConvexHull === undefined ) {\n\n\t\t\tconsole.error( 'THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on ConvexHull' );\n\n\t\t}\n\n\t\tconst convexHull = new ConvexHull().setFromPoints( points );\n\n\t\t// generate vertices and normals\n\n\t\tconst faces = convexHull.faces;\n\n\t\tfor ( let i = 0; i < faces.length; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\t\t\tlet edge = face.edge;\n\n\t\t\t// we move along a doubly-connected edge list to access all face points (see HalfEdge docs)\n\n\t\t\tdo {\n\n\t\t\t\tconst point = edge.head().point;\n\n\t\t\t\tvertices.push( point.x, point.y, point.z );\n\t\t\t\tnormals.push( face.normal.x, face.normal.y, face.normal.z );\n\n\t\t\t\tedge = edge.next;\n\n\t\t\t} while ( edge !== face.edge );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t}\n\n}\n\nexport { ConvexGeometry };\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tMathUtils,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\n\nfunction computeTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst srcArray = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;\n\t\t\tconst dstArray = new Float32Array( attribute.getCount() * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.getCount(); i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = MathUtils.denormalize( attribute.getX( i ), srcArray );\n\t\t\t\tdstArray[ j ++ ] = MathUtils.denormalize( attribute.getY( i ), srcArray );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = MathUtils.denormalize( attribute.getZ( i ), srcArray );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry )\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeBufferGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\t// gather .userData\n\n\t\tmergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n\t\tmergedGeometry.userData.mergedUserData.push( geometry.userData );\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeBufferAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeBufferAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeBufferAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tarray.set( attributes[ i ].array, offset );\n\n\t\toffset += attributes[ i ].array.length;\n\n\t}\n\n\treturn new BufferAttribute( array, itemSize, normalized );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst attrArrays = {};\n\tconst morphAttrsArrays = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\n\t// initialize the arrays\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\n\t\tattrArrays[ name ] = [];\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\tmorphAttrsArrays[ name ] = new Array( morphAttr.length ).fill().map( () => [] );\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst decimalShift = Math.log10( 1 / tolerance );\n\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the attribute arrays\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = attrArrays[ name ];\n\t\t\t\tconst newMorphArrays = morphAttrsArrays[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tnewarray.push( attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ].push( morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// Generate typed arrays from new attribute arrays and update\n\t// the attributeBuffers\n\tconst result = geometry.clone();\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst oldAttribute = geometry.getAttribute( name );\n\n\t\tconst buffer = new oldAttribute.array.constructor( attrArrays[ name ] );\n\t\tconst attribute = new BufferAttribute( buffer, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\tresult.setAttribute( name, attribute );\n\n\t\t// Update the attribute arrays\n\t\tif ( name in morphAttrsArrays ) {\n\n\t\t\tfor ( let j = 0; j < morphAttrsArrays[ name ].length; j ++ ) {\n\n\t\t\t\tconst oldMorphAttribute = geometry.morphAttributes[ name ][ j ];\n\n\t\t\t\tconst buffer = new oldMorphAttribute.array.constructor( morphAttrsArrays[ name ][ j ] );\n\t\t\t\tconst morphAttribute = new BufferAttribute( buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized );\n\t\t\t\tresult.morphAttributes[ name ][ j ] = morphAttribute;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry>}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tif ( object.geometry.isBufferGeometry !== true ) {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.' );\n\t\treturn null;\n\n\t}\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tmaterial,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( material.morphTargets && morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.boneTransform( a, _vA );\n\t\t\tobject.boneTransform( b, _vB );\n\t\t\tobject.boneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group, groupMaterial;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\nexport {\n\tcomputeTangents,\n\tmergeBufferGeometries,\n\tmergeBufferAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups\n};\n"],"names":["IsObject","url","Object","Array","isArray","useTexture","input","gl","useThree","state","textures","useLoader","TextureLoader","values","useEffect","forEach","initTexture","keys","keyed","key","assign","indexOf","preload","clear","_v1","Vector3","_line3","Line3","_plane","Plane","_closestPoint","_triangle","Triangle","ConvexHull","this","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","points","length","makeEmpty","i","l","push","VertexNode","compute","object","updateMatrixWorld","traverse","node","geometry","undefined","isGeometry","console","error","isBufferGeometry","attribute","attributes","position","count","point","fromBufferAttribute","applyMatrix4","matrixWorld","setFromPoints","distanceToPoint","ray","target","tNear","Infinity","tFar","face","vN","origin","vD","normal","dot","direction","t","Math","min","max","at","intersectRay","vertex","outside","append","insertBefore","next","remove","start","end","removeSubList","prev","absorbingFace","faceVertices","removeAllVerticesFromFace","appendChain","nextVertex","addVertexToFace","isEmpty","first","maxDistance","maxFace","mark","distance","minVertices","maxVertices","copy","j","getComponent","setComponent","Number","EPSILON","abs","x","y","z","extremes","computeExtremes","index","v2","v3","v0","v1","set","closestPointToPoint","distanceToSquared","setFromCoplanarPoints","Face","create","getEdge","setTwin","activeFaces","eyeVertex","eyeFace","eyePoint","crossEdge","horizon","edge","deleteFaceVertices","twinEdge","twin","oppositeFace","computeHorizon","horizonEdge","tail","head","firstSideEdge","previousSideEdge","sideEdge","addAdjoiningFace","removeVertexFromFace","addNewFaces","resolveUnassignedPoints","computeInitialHull","nextVertexToAdd","addVertexToHull","reindexFaces","cleanup","midpoint","area","constant","a","b","c","getNormal","getMidpoint","getArea","e0","HalfEdge","e1","e2","distanceTo","ConvexGeometry","normals","convexHull","setAttribute","Float32BufferAttribute","BufferGeometry","mergeVertices","hashToIndex","indices","getIndex","positions","getAttribute","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","getters","name","morphAttr","morphAttributes","fill","map","decimalShift","log10","shiftMultiplier","pow","getX","hash","itemSize","k","newarray","newMorphArrays","getterFunc","m","ml","result","clone","oldAttribute","buffer","array","constructor","BufferAttribute","normalized","oldMorphAttribute","morphAttribute","setIndex"],"sourceRoot":""}