"use strict";(self.webpackChunkthreejs_examples_with_fiber=self.webpackChunkthreejs_examples_with_fiber||[]).push([[664],{9740:function(e,t,r){r.d(t,{m:function(){return s}});var i=r(4942),o=r(7760),u=r(2794),n=r(2791),a=function(e){return e===Object(e)&&!Array.isArray(e)&&"function"!==typeof e};function s(e){var t=(0,u.w)((function(e){return e.gl})),r=(0,u.z)(o.TextureLoader,a(e)?Object.values(e):e);if((0,n.useEffect)((function(){(Array.isArray(r)?r:[r]).forEach(t.initTexture)}),[t,r]),a(e)){var s=Object.keys(e),f={};return s.forEach((function(e){return Object.assign(f,(0,i.Z)({},e,r[s.indexOf(e)]))})),f}return r}s.preload=function(e){return u.z.preload(o.TextureLoader,e)},s.clear=function(e){return u.z.clear(o.TextureLoader,e)}},7133:function(e,t,r){r.d(t,{$1:function(){return n},qf:function(){return o}});var i=r(7760);function o(e){for(var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=null!==e[0].index,o=new Set(Object.keys(e[0].attributes)),n=new Set(Object.keys(e[0].morphAttributes)),a={},s={},f=e[0].morphTargetsRelative,l=new i.BufferGeometry,m=0,h=0;h<e.length;++h){var c=e[h],g=0;if(r!==(null!==c.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(var b in c.attributes){if(!o.has(b))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+'. All geometries must have compatible attributes; make sure "'+b+'" attribute exists among all geometries, or in none of them.'),null;void 0===a[b]&&(a[b]=[]),a[b].push(c.attributes[b]),g++}if(g!==o.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". Make sure all geometries have the same number of attributes."),null;if(f!==c.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(var d in c.morphAttributes){if(!n.has(d))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===s[d]&&(s[d]=[]),s[d].push(c.morphAttributes[d])}if(l.userData.mergedUserData=l.userData.mergedUserData||[],l.userData.mergedUserData.push(c.userData),t){var v=void 0;if(r)v=c.index.count;else{if(void 0===c.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+h+". The geometry must have either an index or a position attribute"),null;v=c.attributes.position.count}l.addGroup(m,v,h),m+=v}}if(r){for(var p=0,y=[],A=0;A<e.length;++A){for(var B=e[A].index,E=0;E<B.count;++E)y.push(B.getX(E)+p);p+=e[A].attributes.position.count}l.setIndex(y)}for(var x in a){var w=u(a[x]);if(!w)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+x+" attribute."),null;l.setAttribute(x,w)}for(var G in s){var T=s[G][0].length;if(0===T)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[G]=[];for(var z=0;z<T;++z){for(var R=[],U=0;U<s[G].length;++U)R.push(s[G][U][z]);var k=u(R);if(!k)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+G+" morphAttribute."),null;l.morphAttributes[G].push(k)}}return l}function u(e){for(var t,r,o,u=0,n=0;n<e.length;++n){var a=e[n];if(a.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===t&&(t=a.array.constructor),t!==a.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===r&&(r=a.itemSize),r!==a.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===o&&(o=a.normalized),o!==a.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;u+=a.array.length}for(var s=new t(u),f=0,l=0;l<e.length;++l)s.set(e[l].array,f),f+=e[l].array.length;return new i.BufferAttribute(s,r,o)}function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e-4;t=Math.max(t,Number.EPSILON);for(var r={},o=e.getIndex(),u=e.getAttribute("position"),n=o?o.count:u.count,a=0,s=Object.keys(e.attributes),f={},l={},m=[],h=["getX","getY","getZ","getW"],c=0,g=s.length;c<g;c++){var b=s[c];f[b]=[];var d=e.morphAttributes[b];d&&(l[b]=new Array(d.length).fill().map((function(){return[]})))}for(var v=Math.log10(1/t),p=Math.pow(10,v),y=0;y<n;y++){for(var A=o?o.getX(y):y,B="",E=0,x=s.length;E<x;E++)for(var w=s[E],G=e.getAttribute(w),T=G.itemSize,z=0;z<T;z++)B+="".concat(~~(G[h[z]](A)*p),",");if(B in r)m.push(r[B]);else{for(var R=0,U=s.length;R<U;R++)for(var k=s[R],H=e.getAttribute(k),S=e.morphAttributes[k],j=H.itemSize,O=f[k],D=l[k],I=0;I<j;I++){var _=h[I];if(O.push(H[_](A)),S)for(var L=0,M=S.length;L<M;L++)D[L].push(S[L][_](A))}r[B]=a,m.push(a),a++}}for(var X=e.clone(),C=0,N=s.length;C<N;C++){var Z=s[C],q=e.getAttribute(Z),P=new q.array.constructor(f[Z]),W=new i.BufferAttribute(P,q.itemSize,q.normalized);if(X.setAttribute(Z,W),Z in l)for(var Y=0;Y<l[Z].length;Y++){var $=e.morphAttributes[Z][Y],F=new $.array.constructor(l[Z][Y]),J=new i.BufferAttribute(F,$.itemSize,$.normalized);X.morphAttributes[Z][Y]=J}}return X.setIndex(m),X}}}]);
//# sourceMappingURL=664.67f34af1.chunk.js.map