{"version":3,"file":"static/js/839.535c41e4.chunk.js","mappings":"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","sources":["contants.tsx","../node_modules/three/examples/jsm/geometries/DecalGeometry.js","webgl/decals/Example.tsx"],"sourcesContent":["export const canvas_width = window.innerWidth > 640 ? (window.innerWidth - 300) : window.innerWidth\nexport const canvas_height = window.innerWidth > 640 ? window.innerHeight : (window.innerHeight - 48)\n\nexport const aspect_ratio = canvas_width / canvas_height","import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tMatrix4,\n\tVector3\n} from 'three';\n\n/**\n * You can use this geometry to create a decal mesh, that serves different kinds of purposes.\n * e.g. adding unique details to models, performing dynamic visual environmental changes or covering seams.\n *\n * Constructor parameter:\n *\n * mesh — Any mesh object\n * position — Position of the decal projector\n * orientation — Orientation of the decal projector\n * size — Size of the decal projector\n *\n * reference: http://blog.wolfire.com/2009/06/how-to-project-decals/\n *\n */\n\nclass DecalGeometry extends BufferGeometry {\n\n\tconstructor( mesh, position, orientation, size ) {\n\n\t\tsuper();\n\n\t\t// buffers\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helpers\n\n\t\tconst plane = new Vector3();\n\n\t\t// this matrix represents the transformation of the decal projector\n\n\t\tconst projectorMatrix = new Matrix4();\n\t\tprojectorMatrix.makeRotationFromEuler( orientation );\n\t\tprojectorMatrix.setPosition( position );\n\n\t\tconst projectorMatrixInverse = new Matrix4();\n\t\tprojectorMatrixInverse.copy( projectorMatrix ).invert();\n\n\t\t// generate buffers\n\n\t\tgenerate();\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction generate() {\n\n\t\t\tlet decalVertices = [];\n\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst normal = new Vector3();\n\n\t\t\t// handle different geometry types\n\n\t\t\tif ( mesh.geometry.isGeometry === true ) {\n\n\t\t\t\tconsole.error( 'THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst geometry = mesh.geometry;\n\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst normalAttribute = geometry.attributes.normal;\n\n\t\t\t// first, create an array of 'DecalVertex' objects\n\t\t\t// three consecutive 'DecalVertex' objects represent a single face\n\t\t\t//\n\t\t\t// this data structure will be later used to perform the clipping\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t// indexed BufferGeometry\n\n\t\t\t\tconst index = geometry.index;\n\n\t\t\t\tfor ( let i = 0; i < index.count; i ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( positionAttribute, index.getX( i ) );\n\t\t\t\t\tnormal.fromBufferAttribute( normalAttribute, index.getX( i ) );\n\n\t\t\t\t\tpushDecalVertex( decalVertices, vertex, normal );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed BufferGeometry\n\n\t\t\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\tnormal.fromBufferAttribute( normalAttribute, i );\n\n\t\t\t\t\tpushDecalVertex( decalVertices, vertex, normal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// second, clip the geometry so that it doesn't extend out from the projector\n\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 1, 0, 0 ) );\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( - 1, 0, 0 ) );\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, 1, 0 ) );\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, - 1, 0 ) );\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, 0, 1 ) );\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, 0, - 1 ) );\n\n\t\t\t// third, generate final vertices, normals and uvs\n\n\t\t\tfor ( let i = 0; i < decalVertices.length; i ++ ) {\n\n\t\t\t\tconst decalVertex = decalVertices[ i ];\n\n\t\t\t\t// create texture coordinates (we are still in projector space)\n\n\t\t\t\tuvs.push(\n\t\t\t\t\t0.5 + ( decalVertex.position.x / size.x ),\n\t\t\t\t\t0.5 + ( decalVertex.position.y / size.y )\n\t\t\t\t);\n\n\t\t\t\t// transform the vertex back to world space\n\n\t\t\t\tdecalVertex.position.applyMatrix4( projectorMatrix );\n\n\t\t\t\t// now create vertex and normal buffer data\n\n\t\t\t\tvertices.push( decalVertex.position.x, decalVertex.position.y, decalVertex.position.z );\n\t\t\t\tnormals.push( decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushDecalVertex( decalVertices, vertex, normal ) {\n\n\t\t\t// transform the vertex to world space, then to projector space\n\n\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\t\t\tvertex.applyMatrix4( projectorMatrixInverse );\n\n\t\t\tnormal.transformDirection( mesh.matrixWorld );\n\n\t\t\tdecalVertices.push( new DecalVertex( vertex.clone(), normal.clone() ) );\n\n\t\t}\n\n\t\tfunction clipGeometry( inVertices, plane ) {\n\n\t\t\tconst outVertices = [];\n\n\t\t\tconst s = 0.5 * Math.abs( size.dot( plane ) );\n\n\t\t\t// a single iteration clips one face,\n\t\t\t// which consists of three consecutive 'DecalVertex' objects\n\n\t\t\tfor ( let i = 0; i < inVertices.length; i += 3 ) {\n\n\t\t\t\tlet total = 0;\n\t\t\t\tlet nV1;\n\t\t\t\tlet nV2;\n\t\t\t\tlet nV3;\n\t\t\t\tlet nV4;\n\n\t\t\t\tconst d1 = inVertices[ i + 0 ].position.dot( plane ) - s;\n\t\t\t\tconst d2 = inVertices[ i + 1 ].position.dot( plane ) - s;\n\t\t\t\tconst d3 = inVertices[ i + 2 ].position.dot( plane ) - s;\n\n\t\t\t\tconst v1Out = d1 > 0;\n\t\t\t\tconst v2Out = d2 > 0;\n\t\t\t\tconst v3Out = d3 > 0;\n\n\t\t\t\t// calculate, how many vertices of the face lie outside of the clipping plane\n\n\t\t\t\ttotal = ( v1Out ? 1 : 0 ) + ( v2Out ? 1 : 0 ) + ( v3Out ? 1 : 0 );\n\n\t\t\t\tswitch ( total ) {\n\n\t\t\t\t\tcase 0: {\n\n\t\t\t\t\t\t// the entire face lies inside of the plane, no clipping needed\n\n\t\t\t\t\t\toutVertices.push( inVertices[ i ] );\n\t\t\t\t\t\toutVertices.push( inVertices[ i + 1 ] );\n\t\t\t\t\t\toutVertices.push( inVertices[ i + 2 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 1: {\n\n\t\t\t\t\t\t// one vertex lies outside of the plane, perform clipping\n\n\t\t\t\t\t\tif ( v1Out ) {\n\n\t\t\t\t\t\t\tnV1 = inVertices[ i + 1 ];\n\t\t\t\t\t\t\tnV2 = inVertices[ i + 2 ];\n\t\t\t\t\t\t\tnV3 = clip( inVertices[ i ], nV1, plane, s );\n\t\t\t\t\t\t\tnV4 = clip( inVertices[ i ], nV2, plane, s );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( v2Out ) {\n\n\t\t\t\t\t\t\tnV1 = inVertices[ i ];\n\t\t\t\t\t\t\tnV2 = inVertices[ i + 2 ];\n\t\t\t\t\t\t\tnV3 = clip( inVertices[ i + 1 ], nV1, plane, s );\n\t\t\t\t\t\t\tnV4 = clip( inVertices[ i + 1 ], nV2, plane, s );\n\n\t\t\t\t\t\t\toutVertices.push( nV3 );\n\t\t\t\t\t\t\toutVertices.push( nV2.clone() );\n\t\t\t\t\t\t\toutVertices.push( nV1.clone() );\n\n\t\t\t\t\t\t\toutVertices.push( nV2.clone() );\n\t\t\t\t\t\t\toutVertices.push( nV3.clone() );\n\t\t\t\t\t\t\toutVertices.push( nV4 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( v3Out ) {\n\n\t\t\t\t\t\t\tnV1 = inVertices[ i ];\n\t\t\t\t\t\t\tnV2 = inVertices[ i + 1 ];\n\t\t\t\t\t\t\tnV3 = clip( inVertices[ i + 2 ], nV1, plane, s );\n\t\t\t\t\t\t\tnV4 = clip( inVertices[ i + 2 ], nV2, plane, s );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toutVertices.push( nV1.clone() );\n\t\t\t\t\t\toutVertices.push( nV2.clone() );\n\t\t\t\t\t\toutVertices.push( nV3 );\n\n\t\t\t\t\t\toutVertices.push( nV4 );\n\t\t\t\t\t\toutVertices.push( nV3.clone() );\n\t\t\t\t\t\toutVertices.push( nV2.clone() );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 2: {\n\n\t\t\t\t\t\t// two vertices lies outside of the plane, perform clipping\n\n\t\t\t\t\t\tif ( ! v1Out ) {\n\n\t\t\t\t\t\t\tnV1 = inVertices[ i ].clone();\n\t\t\t\t\t\t\tnV2 = clip( nV1, inVertices[ i + 1 ], plane, s );\n\t\t\t\t\t\t\tnV3 = clip( nV1, inVertices[ i + 2 ], plane, s );\n\t\t\t\t\t\t\toutVertices.push( nV1 );\n\t\t\t\t\t\t\toutVertices.push( nV2 );\n\t\t\t\t\t\t\toutVertices.push( nV3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! v2Out ) {\n\n\t\t\t\t\t\t\tnV1 = inVertices[ i + 1 ].clone();\n\t\t\t\t\t\t\tnV2 = clip( nV1, inVertices[ i + 2 ], plane, s );\n\t\t\t\t\t\t\tnV3 = clip( nV1, inVertices[ i ], plane, s );\n\t\t\t\t\t\t\toutVertices.push( nV1 );\n\t\t\t\t\t\t\toutVertices.push( nV2 );\n\t\t\t\t\t\t\toutVertices.push( nV3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! v3Out ) {\n\n\t\t\t\t\t\t\tnV1 = inVertices[ i + 2 ].clone();\n\t\t\t\t\t\t\tnV2 = clip( nV1, inVertices[ i ], plane, s );\n\t\t\t\t\t\t\tnV3 = clip( nV1, inVertices[ i + 1 ], plane, s );\n\t\t\t\t\t\t\toutVertices.push( nV1 );\n\t\t\t\t\t\t\toutVertices.push( nV2 );\n\t\t\t\t\t\t\toutVertices.push( nV3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 3: {\n\n\t\t\t\t\t\t// the entire face lies outside of the plane, so let's discard the corresponding vertices\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn outVertices;\n\n\t\t}\n\n\t\tfunction clip( v0, v1, p, s ) {\n\n\t\t\tconst d0 = v0.position.dot( p ) - s;\n\t\t\tconst d1 = v1.position.dot( p ) - s;\n\n\t\t\tconst s0 = d0 / ( d0 - d1 );\n\n\t\t\tconst v = new DecalVertex(\n\t\t\t\tnew Vector3(\n\t\t\t\t\tv0.position.x + s0 * ( v1.position.x - v0.position.x ),\n\t\t\t\t\tv0.position.y + s0 * ( v1.position.y - v0.position.y ),\n\t\t\t\t\tv0.position.z + s0 * ( v1.position.z - v0.position.z )\n\t\t\t\t),\n\t\t\t\tnew Vector3(\n\t\t\t\t\tv0.normal.x + s0 * ( v1.normal.x - v0.normal.x ),\n\t\t\t\t\tv0.normal.y + s0 * ( v1.normal.y - v0.normal.y ),\n\t\t\t\t\tv0.normal.z + s0 * ( v1.normal.z - v0.normal.z )\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// need to clip more values (texture coordinates)? do it this way:\n\t\t\t// intersectpoint.value = a.value + s * ( b.value - a.value );\n\n\t\t\treturn v;\n\n\t\t}\n\n\t}\n\n}\n\n// helper\n\nclass DecalVertex {\n\n\tconstructor( position, normal ) {\n\n\t\tthis.position = position;\n\t\tthis.normal = normal;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.position.clone(), this.normal.clone() );\n\n\t}\n\n}\n\nexport { DecalGeometry, DecalVertex };\n","import { useState } from 'react'\nimport { Euler, Mesh, MeshPhongMaterial, TextureLoader, Vector2, Vector3 } from 'three'\nimport { GUI } from \"three/examples/jsm/libs/lil-gui.module.min\"\nimport { DecalGeometry } from 'three/examples/jsm/geometries/DecalGeometry.js'\nimport { Canvas } from '@react-three/fiber'\nimport { OrbitControls, useGLTF } from '@react-three/drei'\n\nimport { aspect_ratio } from '../../contants'\n\nimport model from '../../models/LeePerrySmith/LeePerrySmith.glb'\nimport map from '../../models/LeePerrySmith/Map-COL.jpg'\nimport specularMap from '../../models/LeePerrySmith/Map-SPEC.jpg'\nimport normalMap from '../../models/LeePerrySmith/Infinite-Level_02_Tangent_SmoothUV.jpg'\n\nimport decal_diffuse from '../../textures/decal/decal-diffuse.png'\nimport decal_normal from '../../textures/decal/decal-normal.jpg'\n\nuseGLTF.preload(model)\n\nconst textureLoader = new TextureLoader()\nconst mapTexture = textureLoader.load(map)\nconst specularMapTexture = textureLoader.load(specularMap)\nconst normalMapTexture = textureLoader.load(normalMap)\n\nlet mesh: any\n// const decals: any[] = []\nconst params = {\n  minScale: 10,\n  maxScale: 20,\n  rotate: true,\n  clear: () => {\n    // removeDecals()\n  }\n}\n\nconst decalDiffuse = textureLoader.load(decal_diffuse)\nconst decalNormal = textureLoader.load(decal_normal)\nconst decalMaterial = new MeshPhongMaterial({\n  specular: 0x444444,\n  map: decalDiffuse,\n  normalMap: decalNormal,\n  normalScale: new Vector2(1, 1),\n  shininess: 30,\n  transparent: true,\n  depthTest: true,\n  depthWrite: false,\n  polygonOffset: true,\n  polygonOffsetFactor: -4,\n  wireframe: false\n})\n\nconst createControls = () => {\n  const gui = new GUI()\n\n  gui.add(params, 'minScale', 1, 30)\n  gui.add(params, 'maxScale', 1, 30)\n  gui.add(params, 'rotate')\n  gui.add(params, 'clear')\n  gui.open()\n}\n\n// const removeDecals = () => {\n//   decals.forEach(d => {\n//     scene.remove(d)\n//   })\n//   decals.length = 0\n// }\n\nconst Example = () => {\n  const gltf = useGLTF(model) as any\n  mesh = gltf.scene.children[0]\n\n  const [decals, setDecals] = useState<any[]>([])\n\n  const shoot = (event: any) => {\n    const position = event.point\n    const size = new Vector3(10, 10, 10)\n    const scale = params.minScale + Math.random() * (params.maxScale - params.minScale)\n    size.set(scale, scale, scale)\n    const material = decalMaterial.clone()\n    material.color.setHex(Math.random() * 0xffffff)\n\n    const m = new Mesh(new DecalGeometry(mesh, position, new Euler(), size), material)\n    setDecals(decals => [m, ...decals])\n  }\n  \n  return (\n    <Canvas camera={{position: [0, 0, 120], fov: 45, aspect: aspect_ratio, near: 1, far: 1000 }} \n      onCreated={({scene}) => {\n        createControls()\n      }}>\n      <color attach='background' args={['black']} />\n      <ambientLight args={[0x443333]} />\n      <directionalLight args={[0xffddcc, 1]} position={[1, 0.75, 0.5]} />\n      <directionalLight args={[0xccccff, 1]} position={[-1, 0.75, -0.5]} />\n      <primitive object={mesh} scale={10} onClick={shoot}>\n        <meshPhongMaterial specular={0x111111} shininess={25}\n          map={mapTexture}\n          specularMap={specularMapTexture}\n          normalMap={normalMapTexture}\n        />\n      </primitive>\n      {\n        decals.map(d => (\n          <primitive key={d.uuid} object={d} />\n        ))\n      }\n      <OrbitControls \n        minDistance={50}\n        maxDistance={200}\n      />\n    </Canvas>\n  )\n}\n\nexport default Example"],"names":["canvas_width","window","innerWidth","canvas_height","innerHeight","aspect_ratio","DecalGeometry","mesh","position","orientation","size","vertices","normals","uvs","plane","Vector3","projectorMatrix","Matrix4","makeRotationFromEuler","setPosition","projectorMatrixInverse","pushDecalVertex","decalVertices","vertex","normal","applyMatrix4","matrixWorld","transformDirection","push","DecalVertex","clone","clipGeometry","inVertices","outVertices","s","Math","abs","dot","i","length","nV1","nV2","nV3","nV4","v1Out","v2Out","v3Out","clip","v0","v1","p","d0","s0","x","y","z","copy","invert","geometry","isGeometry","console","error","positionAttribute","attributes","normalAttribute","index","count","fromBufferAttribute","getX","set","decalVertex","generate","setAttribute","Float32BufferAttribute","BufferGeometry","this","constructor","useGLTF","model","textureLoader","TextureLoader","mapTexture","load","map","specularMapTexture","specularMap","normalMapTexture","normalMap","params","minScale","maxScale","rotate","clear","decalDiffuse","decal_diffuse","decalNormal","decal_normal","decalMaterial","MeshPhongMaterial","specular","normalScale","Vector2","shininess","transparent","depthTest","depthWrite","polygonOffset","polygonOffsetFactor","wireframe","gltf","scene","children","useState","decals","setDecals","camera","fov","aspect","near","far","onCreated","gui","GUI","add","open","createControls","attach","args","object","scale","onClick","event","point","random","material","color","setHex","m","Mesh","Euler","d","uuid","OrbitControls","minDistance","maxDistance"],"sourceRoot":""}