{"version":3,"file":"static/js/901.157736be.chunk.js","mappings":"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","sources":["../node_modules/three-stdlib/loaders/RGBELoader.js","../node_modules/@react-three/drei/helpers/environment-assets.js","../node_modules/@react-three/drei/core/shapes.js","../node_modules/@react-three/drei/core/Environment.js","../node_modules/@react-three/drei/helpers/glsl/GroundProjection.frag.glsl.js","../node_modules/@react-three/drei/helpers/glsl/GroundProjection.vert.glsl.js","webgl/animation_keyframes/Example.tsx","../node_modules/@react-three/drei/core/useAnimations.js"],"sourcesContent":["import { DataTextureLoader, HalfFloatType, FloatType, DataUtils, LinearEncoding, LinearFilter } from 'three';\n\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n  } // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\n  parse(buffer) {\n    const\n    /* return codes for rgbe routines */\n    //RGBE_RETURN_SUCCESS = 0,\n    RGBE_RETURN_FAILURE = -1,\n\n    /* default error routine.  change this to change error handling */\n    rgbe_read_error = 1,\n          rgbe_write_error = 2,\n          rgbe_format_error = 3,\n          rgbe_memory_error = 4,\n          rgbe_error = function (rgbe_error_code, msg) {\n      switch (rgbe_error_code) {\n        case rgbe_read_error:\n          console.error('THREE.RGBELoader Read Error: ' + (msg || ''));\n          break;\n\n        case rgbe_write_error:\n          console.error('THREE.RGBELoader Write Error: ' + (msg || ''));\n          break;\n\n        case rgbe_format_error:\n          console.error('THREE.RGBELoader Bad File Format: ' + (msg || ''));\n          break;\n\n        default:\n        case rgbe_memory_error:\n          console.error('THREE.RGBELoader: Error: ' + (msg || ''));\n      }\n\n      return RGBE_RETURN_FAILURE;\n    },\n\n    /* offsets to red, green, and blue components in a data (float) pixel */\n    //RGBE_DATA_RED = 0,\n    //RGBE_DATA_GREEN = 1,\n    //RGBE_DATA_BLUE = 2,\n\n    /* number of floats per pixel, use 4 since stored in rgba image format */\n    //RGBE_DATA_SIZE = 4,\n\n    /* flags indicating which fields in an rgbe_header_info are valid */\n    RGBE_VALID_PROGRAMTYPE = 1,\n          RGBE_VALID_FORMAT = 2,\n          RGBE_VALID_DIMENSIONS = 4,\n          NEWLINE = '\\n',\n          fgets = function (buffer, lineLimit, consume) {\n      const chunkSize = 128;\n      lineLimit = !lineLimit ? 1024 : lineLimit;\n      let p = buffer.pos,\n          i = -1,\n          len = 0,\n          s = '',\n          chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n\n      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n        s += chunk;\n        len += chunk.length;\n        p += chunkSize;\n        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n      }\n\n      if (-1 < i) {\n        /*for (i=l-1; i>=0; i--) {\n        byteCode = m.charCodeAt(i);\n        if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n        else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n        if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n        }*/\n        if (false !== consume) buffer.pos += len + i + 1;\n        return s + chunk.slice(0, i);\n      }\n\n      return false;\n    },\n\n    /* minimal header reading.  modify if you want to parse more information */\n    RGBE_ReadHeader = function (buffer) {\n      // regexes to parse header info fields\n      const magic_token_re = /^#\\?(\\S+)/,\n            gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n            exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n            format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n            dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n            // RGBE format header struct\n      header = {\n        valid: 0\n        /* indicate which fields are valid */\n        ,\n        string: ''\n        /* the actual header string */\n        ,\n        comments: ''\n        /* comments found in header */\n        ,\n        programtype: 'RGBE'\n        /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n        ,\n        format: ''\n        /* RGBE format, default 32-bit_rle_rgbe */\n        ,\n        gamma: 1.0\n        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n        ,\n        exposure: 1.0\n        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n        ,\n        width: 0,\n        height: 0\n        /* image dimensions, width/height */\n\n      };\n      let line, match;\n\n      if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n        return rgbe_error(rgbe_read_error, 'no header found');\n      }\n      /* if you want to require the magic token then uncomment the next line */\n\n\n      if (!(match = line.match(magic_token_re))) {\n        return rgbe_error(rgbe_format_error, 'bad initial token');\n      }\n\n      header.valid |= RGBE_VALID_PROGRAMTYPE;\n      header.programtype = match[1];\n      header.string += line + '\\n';\n\n      while (true) {\n        line = fgets(buffer);\n        if (false === line) break;\n        header.string += line + '\\n';\n\n        if ('#' === line.charAt(0)) {\n          header.comments += line + '\\n';\n          continue; // comment line\n        }\n\n        if (match = line.match(gamma_re)) {\n          header.gamma = parseFloat(match[1]);\n        }\n\n        if (match = line.match(exposure_re)) {\n          header.exposure = parseFloat(match[1]);\n        }\n\n        if (match = line.match(format_re)) {\n          header.valid |= RGBE_VALID_FORMAT;\n          header.format = match[1]; //'32-bit_rle_rgbe';\n        }\n\n        if (match = line.match(dimensions_re)) {\n          header.valid |= RGBE_VALID_DIMENSIONS;\n          header.height = parseInt(match[1], 10);\n          header.width = parseInt(match[2], 10);\n        }\n\n        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n      }\n\n      if (!(header.valid & RGBE_VALID_FORMAT)) {\n        return rgbe_error(rgbe_format_error, 'missing format specifier');\n      }\n\n      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n        return rgbe_error(rgbe_format_error, 'missing image size specifier');\n      }\n\n      return header;\n    },\n          RGBE_ReadPixels_RLE = function (buffer, w, h) {\n      const scanline_width = w;\n\n      if ( // run length encoding is not allowed so read flat\n      scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\n      2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {\n        // return the flat buffer\n        return new Uint8Array(buffer);\n      }\n\n      if (scanline_width !== (buffer[2] << 8 | buffer[3])) {\n        return rgbe_error(rgbe_format_error, 'wrong scanline width');\n      }\n\n      const data_rgba = new Uint8Array(4 * w * h);\n\n      if (!data_rgba.length) {\n        return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');\n      }\n\n      let offset = 0,\n          pos = 0;\n      const ptr_end = 4 * scanline_width;\n      const rgbeStart = new Uint8Array(4);\n      const scanline_buffer = new Uint8Array(ptr_end);\n      let num_scanlines = h; // read in each successive scanline\n\n      while (num_scanlines > 0 && pos < buffer.byteLength) {\n        if (pos + 4 > buffer.byteLength) {\n          return rgbe_error(rgbe_read_error);\n        }\n\n        rgbeStart[0] = buffer[pos++];\n        rgbeStart[1] = buffer[pos++];\n        rgbeStart[2] = buffer[pos++];\n        rgbeStart[3] = buffer[pos++];\n\n        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n          return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');\n        } // read each of the four channels for the scanline into the buffer\n        // first red, then green, then blue, then exponent\n\n\n        let ptr = 0,\n            count;\n\n        while (ptr < ptr_end && pos < buffer.byteLength) {\n          count = buffer[pos++];\n          const isEncodedRun = count > 128;\n          if (isEncodedRun) count -= 128;\n\n          if (0 === count || ptr + count > ptr_end) {\n            return rgbe_error(rgbe_format_error, 'bad scanline data');\n          }\n\n          if (isEncodedRun) {\n            // a (encoded) run of the same value\n            const byteValue = buffer[pos++];\n\n            for (let i = 0; i < count; i++) {\n              scanline_buffer[ptr++] = byteValue;\n            } //ptr += count;\n\n          } else {\n            // a literal-run\n            scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n            ptr += count;\n            pos += count;\n          }\n        } // now convert data from buffer into rgba\n        // first red, then green, then blue, then exponent (alpha)\n\n\n        const l = scanline_width; //scanline_buffer.byteLength;\n\n        for (let i = 0; i < l; i++) {\n          let off = 0;\n          data_rgba[offset] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 1] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 2] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 3] = scanline_buffer[i + off];\n          offset += 4;\n        }\n\n        num_scanlines--;\n      }\n\n      return data_rgba;\n    };\n\n    const RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3];\n      const scale = Math.pow(2.0, e - 128.0) / 255.0;\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n      destArray[destOffset + 3] = 1;\n    };\n\n    const RGBEByteToRGBHalf = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3];\n      const scale = Math.pow(2.0, e - 128.0) / 255.0; // clamping to 65504, the maximum representable value in float16\n\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n      destArray[destOffset + 3] = DataUtils.toHalfFloat(1);\n    };\n\n    const byteArray = new Uint8Array(buffer);\n    byteArray.pos = 0;\n    const rgbe_header_info = RGBE_ReadHeader(byteArray);\n\n    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n      const w = rgbe_header_info.width,\n            h = rgbe_header_info.height,\n            image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n\n      if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n        let data, format, type;\n        let numElements;\n\n        switch (this.type) {\n          case FloatType:\n            numElements = image_rgba_data.length / 4;\n            const floatArray = new Float32Array(numElements * 4);\n\n            for (let j = 0; j < numElements; j++) {\n              RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n            }\n\n            data = floatArray;\n            type = FloatType;\n            break;\n\n          case HalfFloatType:\n            numElements = image_rgba_data.length / 4;\n            const halfArray = new Uint16Array(numElements * 4);\n\n            for (let j = 0; j < numElements; j++) {\n              RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n            }\n\n            data = halfArray;\n            type = HalfFloatType;\n            break;\n\n          default:\n            console.error('THREE.RGBELoader: unsupported type: ', this.type);\n            break;\n        }\n\n        return {\n          width: w,\n          height: h,\n          data: data,\n          header: rgbe_header_info.string,\n          gamma: rgbe_header_info.gamma,\n          exposure: rgbe_header_info.exposure,\n          format: format,\n          type: type\n        };\n      }\n    }\n\n    return null;\n  }\n\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case FloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case HalfFloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n      }\n\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n\n}\n\nexport { RGBELoader };\n","const presetsObj = {\n  sunset: 'venice/venice_sunset_1k.hdr',\n  dawn: 'kiara/kiara_1_dawn_1k.hdr',\n  night: 'dikhololo/dikhololo_night_1k.hdr',\n  warehouse: 'empty-wharehouse/empty_warehouse_01_1k.hdr',\n  forest: 'forrest-slope/forest_slope_1k.hdr',\n  apartment: 'lebombo/lebombo_1k.hdr',\n  studio: 'studio-small-3/studio_small_03_1k.hdr',\n  city: 'potsdamer-platz/potsdamer_platz_1k.hdr',\n  park: 'rooitou/rooitou_park_1k.hdr',\n  lobby: 'st-fagans/st_fagans_interior_1k.hdr'\n};\n\nexport { presetsObj };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\n\nfunction create(type) {\n  const El = type + 'BufferGeometry';\n  return /*#__PURE__*/React.forwardRef(({\n    args,\n    children,\n    ...props\n  }, ref) => /*#__PURE__*/React.createElement(\"mesh\", _extends({\n    ref: ref\n  }, props), /*#__PURE__*/React.createElement(El, {\n    attach: \"geometry\",\n    args: args\n  }), children));\n}\n\nconst Box = create('box');\nconst Circle = create('circle');\nconst Cone = create('cone');\nconst Cylinder = create('cylinder');\nconst Sphere = create('sphere');\nconst Plane = create('plane');\nconst Tube = create('tube');\nconst Torus = create('torus');\nconst TorusKnot = create('torusKnot');\nconst Tetrahedron = create('tetrahedron');\nconst Ring = create('ring');\nconst Polyhedron = create('polyhedron');\nconst Icosahedron = create('icosahedron');\nconst Octahedron = create('octahedron');\nconst Dodecahedron = create('dodecahedron');\nconst Extrude = create('extrude');\nconst Lathe = create('lathe');\n\nexport { Box, Circle, Cone, Cylinder, Dodecahedron, Extrude, Icosahedron, Lathe, Octahedron, Plane, Polyhedron, Ring, Sphere, Tetrahedron, Torus, TorusKnot, Tube };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useThree, useLoader, useFrame, createPortal } from '@react-three/fiber';\nimport { CubeReflectionMapping, EquirectangularReflectionMapping, Scene, WebGLCubeRenderTarget, HalfFloatType, CubeTextureLoader, BackSide } from 'three';\nimport { RGBELoader } from 'three-stdlib';\nimport { presetsObj } from '../helpers/environment-assets.js';\nimport vertexShader from '../helpers/glsl/GroundProjection.vert.glsl.js';\nimport fragmentShader from '../helpers/glsl/GroundProjection.frag.glsl.js';\nimport { Icosahedron } from './shapes.js';\n\nconst CUBEMAP_ROOT = 'https://market-assets.fra1.cdn.digitaloceanspaces.com/market-assets/hdris/';\n\nconst isCubeTexture = def => def && def.isCubeTexture;\n\nconst isRef = obj => obj.current && obj.current.isScene;\n\nconst resolveScene = scene => isRef(scene) ? scene.current : scene;\n\nfunction EnvironmentMap({\n  scene,\n  background = false,\n  map\n}) {\n  const defaultScene = useThree(state => state.scene);\n  React.useLayoutEffect(() => {\n    if (map) {\n      const target = resolveScene(scene || defaultScene);\n      const oldbg = target.background;\n      const oldenv = target.environment;\n      if (background !== 'only') target.environment = map;\n      if (background) target.background = map;\n      return () => {\n        if (background !== 'only') target.environment = oldenv;\n        if (background) target.background = oldbg;\n      };\n    }\n  }, [defaultScene, scene, map, background]);\n  return null;\n}\nfunction useEnvironment({\n  files = ['/px.png', '/nx.png', '/py.png', '/ny.png', '/pz.png', '/nz.png'],\n  path = '',\n  preset = undefined,\n  extensions\n}) {\n  if (preset) {\n    if (!(preset in presetsObj)) throw new Error('Preset must be one of: ' + Object.keys(presetsObj).join(', '));\n    files = presetsObj[preset];\n    path = CUBEMAP_ROOT;\n  }\n\n  const isCubeMap = Array.isArray(files);\n  const loader = isCubeMap ? CubeTextureLoader : RGBELoader;\n  const loaderResult = useLoader( // @ts-expect-error\n  loader, isCubeMap ? [files] : files, loader => {\n    loader.setPath(path);\n    if (extensions) extensions(loader);\n  });\n  const texture = isCubeMap ? // @ts-ignore\n  loaderResult[0] : loaderResult;\n  texture.mapping = isCubeMap ? CubeReflectionMapping : EquirectangularReflectionMapping;\n  return texture;\n}\nfunction EnvironmentCube({\n  background = false,\n  scene,\n  ...rest\n}) {\n  const texture = useEnvironment(rest);\n  const defaultScene = useThree(state => state.scene);\n  React.useLayoutEffect(() => {\n    const target = resolveScene(scene || defaultScene);\n    const oldbg = target.background;\n    const oldenv = target.environment;\n    if (background !== 'only') target.environment = texture;\n    if (background) target.background = texture;\n    return () => {\n      if (background !== 'only') target.environment = oldenv;\n      if (background) target.background = oldbg;\n    };\n  }, [texture, background, scene, defaultScene]);\n  return null;\n}\nfunction EnvironmentPortal({\n  children,\n  near = 1,\n  far = 1000,\n  resolution = 256,\n  frames = 1,\n  map,\n  background = false,\n  scene,\n  files,\n  path,\n  preset = undefined,\n  extensions\n}) {\n  const gl = useThree(state => state.gl);\n  const defaultScene = useThree(state => state.scene);\n  const camera = React.useRef(null);\n  const [virtualScene] = React.useState(() => new Scene());\n  const fbo = React.useMemo(() => {\n    const fbo = new WebGLCubeRenderTarget(resolution);\n    fbo.texture.type = HalfFloatType;\n    return fbo;\n  }, [resolution]);\n  React.useLayoutEffect(() => {\n    if (frames === 1) camera.current.update(gl, virtualScene);\n    const target = resolveScene(scene || defaultScene);\n    const oldbg = target.background;\n    const oldenv = target.environment;\n    if (background !== 'only') target.environment = fbo.texture;\n    if (background) target.background = fbo.texture;\n    return () => {\n      if (background !== 'only') target.environment = oldenv;\n      if (background) target.background = oldbg;\n    };\n  }, [children, virtualScene, fbo.texture, scene, defaultScene, background, frames, gl]);\n  let count = 1;\n  useFrame(() => {\n    if (frames === Infinity || count < frames) {\n      camera.current.update(gl, virtualScene);\n      count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal( /*#__PURE__*/React.createElement(React.Fragment, null, children, /*#__PURE__*/React.createElement(\"cubeCamera\", {\n    ref: camera,\n    args: [near, far, fbo]\n  }), files || preset ? /*#__PURE__*/React.createElement(EnvironmentCube, {\n    background: true,\n    files: files,\n    preset: preset,\n    path: path,\n    extensions: extensions\n  }) : map ? /*#__PURE__*/React.createElement(EnvironmentMap, {\n    background: true,\n    map: map,\n    extensions: extensions\n  }) : null), virtualScene));\n}\n\nfunction EnvironmentGround(props) {\n  var _props$ground, _props$ground2, _scale, _props$ground3;\n\n  const textureDefault = useEnvironment(props);\n  const texture = props.map || textureDefault;\n  const isCubeMap = isCubeTexture(texture);\n  const defines = React.useMemo(() => {\n    var _ref, _texture$image$;\n\n    const w = (_ref = isCubeMap ? (_texture$image$ = texture.image[0]) == null ? void 0 : _texture$image$.width : texture.image.width) !== null && _ref !== void 0 ? _ref : 1024;\n    const cubeSize = w / 4;\n\n    const _lodMax = Math.floor(Math.log2(cubeSize));\n\n    const _cubeSize = Math.pow(2, _lodMax);\n\n    const width = 3 * Math.max(_cubeSize, 16 * 7);\n    const height = 4 * _cubeSize;\n    return [isCubeMap ? `#define ENVMAP_TYPE_CUBE` : '', `#define CUBEUV_TEXEL_WIDTH ${1.0 / width}`, `#define CUBEUV_TEXEL_HEIGHT ${1.0 / height}`, `#define CUBEUV_MAX_MIP ${_lodMax}.0`, ``];\n  }, []);\n  const fragment = React.useMemo(() => defines.join('\\n') + fragmentShader, [defines]);\n  const uniforms = React.useMemo(() => ({\n    cubemap: {\n      value: null\n    },\n    height: {\n      value: 15\n    },\n    radius: {\n      value: 60\n    }\n  }), []);\n  const mat = React.useRef(null);\n  const height = (_props$ground = props.ground) == null ? void 0 : _props$ground.height;\n  const radius = (_props$ground2 = props.ground) == null ? void 0 : _props$ground2.radius;\n  const scale = (_scale = (_props$ground3 = props.ground) == null ? void 0 : _props$ground3.scale) !== null && _scale !== void 0 ? _scale : 1000;\n  React.useEffect(() => void (height && (mat.current.uniforms.height.value = height)), [height]);\n  React.useEffect(() => void (radius && (mat.current.uniforms.radius.value = radius)), [radius]);\n  React.useEffect(() => void (mat.current.uniforms.cubemap.value = texture), [texture]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(EnvironmentMap, _extends({}, props, {\n    map: texture\n  })), /*#__PURE__*/React.createElement(Icosahedron, {\n    scale: scale,\n    args: [1, 16]\n  }, /*#__PURE__*/React.createElement(\"shaderMaterial\", {\n    ref: mat,\n    side: BackSide,\n    vertexShader: vertexShader,\n    fragmentShader: fragment,\n    uniforms: uniforms,\n    depthTest: false\n  })));\n}\n\nfunction Environment(props) {\n  return props.ground ? /*#__PURE__*/React.createElement(EnvironmentGround, props) : props.map ? /*#__PURE__*/React.createElement(EnvironmentMap, props) : props.children ? /*#__PURE__*/React.createElement(EnvironmentPortal, props) : /*#__PURE__*/React.createElement(EnvironmentCube, props);\n}\n\nexport { Environment, EnvironmentCube, EnvironmentMap, EnvironmentPortal, useEnvironment };\n","var fragmentShader = \"#define GLSLIFY 1\\n#define ENVMAP_TYPE_CUBE_UV\\nvarying vec3 vWorldPosition;uniform float radius;uniform float height;\\n#ifdef ENVMAP_TYPE_CUBE\\nuniform samplerCube cubemap;\\n#else\\nuniform sampler2D cubemap;\\n#endif\\nfloat diskIntersect(in vec3 ro,in vec3 rd,vec3 c,vec3 n,float r){vec3 o=ro-c;float t=-dot(n,o)/dot(rd,n);vec3 q=o+rd*t;return(dot(q,q)<r*r)? t : 1e6;}float sphereIntersect(in vec3 ro,in vec3 rd,in vec3 ce,float ra){vec3 oc=ro-ce;float b=dot(oc,rd);float c=dot(oc,oc)-ra*ra;float h=b*b-c;if(h<0.0)-1.0;h=sqrt(h);return-b+h;}vec3 project(){vec3 p=normalize(vWorldPosition);vec3 camPos=cameraPosition;camPos.y-=height;float intersection=sphereIntersect(camPos,p,vec3(0.),radius);if(intersection>0.){vec3 h=vec3(0.0,-height,0.0);float intersection2=diskIntersect(camPos,p,h,vec3(0.0,-1.0,0.0),radius);p=(camPos+min(intersection,intersection2)*p)/radius;}else{p=vec3(0.0,1.0,0.0);}return p;}\\n#include <common>\\n#include <cube_uv_reflection_fragment>\\nvoid main(){vec3 projectedWorldPosition=project();\\n#ifdef ENVMAP_TYPE_CUBE\\nvec3 outcolor=textureCube(cubemap,projectedWorldPosition).rgb;\\n#else\\nvec3 direction=normalize(projectedWorldPosition);vec2 uv=equirectUv(direction);vec3 outcolor=texture2D(cubemap,uv).rgb;\\n#endif\\ngl_FragColor=vec4(outcolor,1.0);\\n#include <tonemapping_fragment>\\n#include <encodings_fragment>\\n}\"; // eslint-disable-line\n\nexport { fragmentShader as default };\n","var vertexShader = \"#define GLSLIFY 1\\nvarying vec3 vWorldPosition;void main(){vec4 worldPosition=modelMatrix*vec4(position,1.0);vWorldPosition=worldPosition.xyz;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}\"; // eslint-disable-line\n\nexport { vertexShader as default };\n","import { Suspense, useEffect } from \"react\"\nimport { Canvas } from \"@react-three/fiber\"\nimport { Environment, OrbitControls, useAnimations, useGLTF } from \"@react-three/drei\"\n\nimport model from '../../models/LittlestTokyo.glb'\n\nuseGLTF.preload(model)\nconst Model = () => {\n  const { scene, animations }: any = useGLTF(model)\n  const { actions } = useAnimations(animations, scene)\n\n  useEffect(() => {\n    actions[\"Take 001\"]?.play()\n  }, [actions, scene])\n\n  return (\n    <primitive object={scene} scale={[0.01, 0.01, 0.01]} position={[1, 1, 0]} />\n  )\n}\n\nconst Example = () => {\n  return (\n    <Canvas \n      camera={{ position: [5, 2, 8], fov: 40, near:1, far: 100 }}\n      dpr={[1, 2]}>\n      <color attach=\"background\" args={[0xbfe3dd]} />\n      <Environment preset='warehouse' />\n      <Suspense fallback={null}>\n        <Model />\n      </Suspense>\n      <OrbitControls target={[0, 0.5, 0]} enableDamping enablePan={false} />\n    </Canvas>\n  )\n}\n\nexport default Example","import * as React from 'react';\nimport { Object3D, AnimationMixer } from 'three';\nimport { useFrame } from '@react-three/fiber';\n\nfunction useAnimations(clips, root) {\n  const ref = React.useRef();\n  const [actualRef] = React.useState(() => root ? root instanceof Object3D ? {\n    current: root\n  } : root : ref); // eslint-disable-next-line prettier/prettier\n\n  const [mixer] = React.useState(() => new AnimationMixer(undefined));\n  const lazyActions = React.useRef({});\n  const [api] = React.useState(() => {\n    const actions = {};\n    clips.forEach(clip => Object.defineProperty(actions, clip.name, {\n      enumerable: true,\n\n      get() {\n        if (actualRef.current) {\n          return lazyActions.current[clip.name] || (lazyActions.current[clip.name] = mixer.clipAction(clip, actualRef.current));\n        }\n      }\n\n    }));\n    return {\n      ref: actualRef,\n      clips,\n      actions,\n      names: clips.map(c => c.name),\n      mixer\n    };\n  });\n  useFrame((state, delta) => mixer.update(delta));\n  React.useEffect(() => {\n    const currentRoot = actualRef.current;\n    return () => {\n      // Clean up only when clips change, wipe out lazy actions and uncache clips\n      lazyActions.current = {};\n      Object.values(api.actions).forEach(action => {\n        if (currentRoot) {\n          mixer.uncacheAction(action, currentRoot);\n        }\n      });\n    };\n  }, [clips]);\n  return api;\n}\n\nexport { useAnimations };\n"],"names":["RGBELoader","manager","type","HalfFloatType","buffer","rgbe_error","rgbe_error_code","msg","console","error","fgets","lineLimit","consume","p","pos","i","len","s","chunk","String","fromCharCode","apply","Uint16Array","subarray","indexOf","byteLength","length","slice","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","e","scale","Math","pow","RGBEByteToRGBHalf","DataUtils","min","byteArray","Uint8Array","rgbe_header_info","line","match","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","width","height","charAt","parseFloat","parseInt","RGBE_ReadHeader","w","h","image_rgba_data","scanline_width","data_rgba","offset","ptr_end","rgbeStart","scanline_buffer","num_scanlines","ptr","count","isEncodedRun","byteValue","set","l","off","RGBE_ReadPixels_RLE","data","numElements","this","FloatType","floatArray","Float32Array","j","halfArray","value","url","onLoad","onProgress","onError","texture","texData","encoding","LinearEncoding","minFilter","LinearFilter","magFilter","generateMipmaps","flipY","DataTextureLoader","presetsObj","sunset","dawn","night","warehouse","forest","apartment","studio","city","park","lobby","create","El","React","ref","args","children","props","_extends","attach","Icosahedron","resolveScene","scene","obj","current","isScene","EnvironmentMap","background","map","defaultScene","useThree","state","target","oldbg","oldenv","environment","useEnvironment","files","path","preset","undefined","extensions","Error","Object","keys","join","isCubeMap","Array","isArray","loader","CubeTextureLoader","loaderResult","useLoader","setPath","mapping","CubeReflectionMapping","EquirectangularReflectionMapping","EnvironmentCube","EnvironmentPortal","near","far","resolution","frames","gl","camera","Scene","virtualScene","fbo","WebGLCubeRenderTarget","update","useFrame","Infinity","createPortal","EnvironmentGround","_props$ground","_props$ground2","_scale","_props$ground3","def","textureDefault","isCubeTexture","defines","_ref","_texture$image$","cubeSize","image","_lodMax","floor","log2","_cubeSize","max","fragment","uniforms","cubemap","radius","mat","ground","side","BackSide","vertexShader","fragmentShader","depthTest","Environment","useGLTF","model","Model","clips","root","Object3D","actualRef","AnimationMixer","mixer","lazyActions","actions","forEach","clip","defineProperty","name","enumerable","get","clipAction","names","c","api","delta","currentRoot","values","action","uncacheAction","useAnimations","animations","useEffect","play","object","position","fov","dpr","Suspense","fallback","OrbitControls","enableDamping","enablePan"],"sourceRoot":""}