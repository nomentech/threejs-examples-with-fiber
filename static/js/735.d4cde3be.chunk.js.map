{"version":3,"file":"static/js/735.d4cde3be.chunk.js","mappings":"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","sources":["contants.tsx","webgl/clipping_advanced/Example.tsx"],"sourcesContent":["export const canvas_width = window.innerWidth > 640 ? (window.innerWidth - 300) : window.innerWidth\nexport const canvas_height = window.innerWidth > 640 ? window.innerHeight : (window.innerHeight - 48)\n\nexport const aspect_ratio = canvas_width / canvas_height","import { useRef } from 'react'\nimport * as THREE from 'three'\nimport { Canvas, useFrame, useThree } from '@react-three/fiber'\nimport { OrbitControls } from '@react-three/drei'\nimport { useControls } from 'leva'\n\nimport { aspect_ratio } from '../../contants'\n\nlet clipMaterial: THREE.MeshPhongMaterial\nlet globalClippingPlanes: any[]\nlet volumeVisualization: THREE.Group\n\nconst planesFromMesh = (vertices: THREE.Vector3[], indices: number[]) => {\n  // creates a clipping volume from a convex triangular mesh\n  // specified by the arrays 'vertices' and 'indices'\n\n  const n = indices.length / 3\n  const result = new Array(n)\n\n  for (let i = 0, j = 0; i < n; ++i, j+= 3) {\n    const a = vertices[indices[j]]\n    const b = vertices[indices[j+1]]\n    const c = vertices[indices[j+2]]\n\n    result[i] = new THREE.Plane().setFromCoplanarPoints(a, b, c)\n  }\n\n  return result\n}\n\nconst planeToMatrix = (function () {\n  // creates a matrix that aligns X/Y to a given plane\n\n  // temporaries:\n  const xAxis = new THREE.Vector3()\n  const yAxis = new THREE.Vector3()\n  const trans = new THREE.Vector3()\n\n  return function planeToMatrix(plane: any) {\n\n    const zAxis = plane.normal\n    const matrix = new THREE.Matrix4()\n\n    // Hughes & Moeller '99\n    // \"Building an Orthonormal Basis from a Unit Vector.\"\n    if (Math.abs(zAxis.x) > Math.abs(zAxis.z)) {\n      yAxis.set(-zAxis.y, zAxis.x, 0)\n    } else {\n      yAxis.set(0, -zAxis.z, zAxis.y)\n    }\n\n    xAxis.crossVectors(yAxis.normalize(), zAxis)\n\n    plane.coplanarPoint(trans)\n\n    return matrix.set(\n      xAxis.x, yAxis.x, zAxis.x, trans.x,\n      xAxis.y, yAxis.y, zAxis.y, trans.y,\n      xAxis.z, yAxis.z, zAxis.z, trans.z,\n      0,\t 0, 0, 1)\n  }\n})()\n\nconst createPlanes = (n: number) => {\n  // creates an array of n uninitialized plane objects\n  const result = new Array(n)\n\n  for (let i = 0; i !== n; ++i)\n    result[i] = new THREE.Plane()\n\n  return result\n}\n\nconst assignTransformedPlanes = (planesOut: any[], planesIn: any[], matrix: THREE.Matrix4) => {\n  // sets an array of existing planes to transformed 'planesIn'\n  for (let i = 0, n = planesIn.length; i !== n; ++ i)\n    planesOut[i].copy(planesIn[i]).applyMatrix4(matrix)\n}\n\nconst cylindricalPlanes = (n: number, innerRadius: number) => {\n  const result = createPlanes(n)\n\n  for (let i = 0; i !== n; ++ i) {\n    const plane = result[i]\n    const angle = i * Math.PI * 2 / n\n\n    plane.normal.set(\n      Math.cos(angle), 0, Math.sin(angle))\n\n    plane.constant = innerRadius\n  }\n\n  return result\n}\n\nconst setObjectWorldMatrix = (object: any, matrix: THREE.Matrix4) => {  \n  // set the orientation of an object based on a world matrix\n  const parent = object.parent\n  // scene.updateMatrixWorld()\n  object.matrix.copy( parent.matrixWorld ).invert()\n  object.applyMatrix4(matrix)\n}\n\nconst Vertices = [\n  new THREE.Vector3(1, 0, Math.SQRT1_2),\n  new THREE.Vector3(-1, 0, Math.SQRT1_2),\n  new THREE.Vector3(0, 1, -Math.SQRT1_2),\n  new THREE.Vector3(0, -1, -Math.SQRT1_2)\n]\nconst Indices = [0, 1, 2,   0, 2, 3,  0, 3, 1,   1, 3, 2]\nconst Planes = planesFromMesh(Vertices, Indices)\nconst PlaneMatrices = Planes.map(planeToMatrix)\nconst GlobalClippingPlanes = cylindricalPlanes(5, 2.5)\nconst Empty = Object.freeze([])\n\nconst transform = new THREE.Matrix4()\nconst tmpMatrix = new THREE.Matrix4()\n\nconst Controls = () => {\n  const { gl } = useThree()\n\n  // Clipping setup\n  globalClippingPlanes = createPlanes(GlobalClippingPlanes.length)\n  gl.clippingPlanes = Empty as any\n  gl.localClippingEnabled = true\n\n  useControls('Local Clipping', {\n    'Enabled': {\n      value: gl.localClippingEnabled,\n      onChange: (v: boolean) => {\n        gl.localClippingEnabled = v\n        if (!v) volumeVisualization.visible = false\n      }\n    },\n    'Shadow': {\n      value: clipMaterial.clipShadows,\n      onChange: (v: boolean) => clipMaterial.clipShadows = v\n    },\n    'Visualize': {\n      value: volumeVisualization.visible,\n      onChange: (v: boolean) => {\n        if (gl.localClippingEnabled) volumeVisualization.visible = v\n      }\n    }\n  })\n\n  useControls('Global Clipping', {\n    'Enabled': {\n      value: gl.clippingPlanes !== Empty as any,\n      onChange: (v: boolean) => {\n        gl.clippingPlanes = v ?\n          globalClippingPlanes : Empty as any\n      }\n    }\n  })\n\n  return null\n}\n\nconst Light = () => {\n  return (\n    <>\n      <ambientLight args={[0xffffff, 0.3]} />\n      <spotLight color={0xffffff} intensity={0.5} angle={Math.PI / 5} \n        penumbra={0.2} position={[2, 3, 3]} castShadow \n        shadow-camera-near={3} shadow-camera-far={10}\n        shadow-mapSize-width={1024} shadow-mapSize-height={1024} />\n      <directionalLight color={0xffffff} intensity={0.5} position={[0, 2, 0]} castShadow \n        shadow-mapSize={[1024, 1024]}\n        // shadow-camera-near={1} shadow-camera-far={10} \n        // shadow-camera-right={1} shadow-camera-left={-1}\n        // shadow-camera-top={1} shadow-camera-bottom={-1}\n        // shadow-mapSize-width={1024} shadow-mapSize-height={1024} \n      >\n        <orthographicCamera attach='shadow-camera' args={[-1, 1, 1, -1, 1, 10]} />\n      </directionalLight>\n    </>\n  )\n}\n\nconst Meshes = () => {\n  clipMaterial = new THREE.MeshPhongMaterial({\n    color: 0xee0a10,\n    shininess: 100,\n    side: THREE.DoubleSide,\n    // Clipping setup\n    clippingPlanes: createPlanes(Planes.length),\n    clipShadows: true\n  })\n\n  const meshRef: any = useRef()\n  useFrame(({ clock }) => {\n    const time = clock.getElapsedTime()\n\n    meshRef.current.position.y = 1\n    meshRef.current.rotation.x = time * 0.5\n    meshRef.current.rotation.y = time * 0.2\n\n    meshRef.current.updateMatrix()\n    transform.copy(meshRef.current.matrix)\n    const bouncy = Math.cos(time*0.5)*0.5 + 0.7\n    transform.multiply(tmpMatrix.makeScale(bouncy, bouncy, bouncy))\n\n    assignTransformedPlanes(clipMaterial.clippingPlanes, Planes, transform)\n    const planeMeshes = volumeVisualization.children\n\n    for (let i = 0, n = planeMeshes.length; i !== n; ++ i) {\n      tmpMatrix.multiplyMatrices(transform, PlaneMatrices[i])\n      setObjectWorldMatrix(planeMeshes[i], tmpMatrix)\n    }\n    transform.makeRotationY(time * 0.1)\n    assignTransformedPlanes(globalClippingPlanes, GlobalClippingPlanes, transform)\n  })\n\n  const meshes = []\n  for (let z = - 2; z <= 2; ++ z)\n    for (let y = - 2; y <= 2; ++ y)\n      for (let x = - 2; x <= 2; ++ x) {\n        meshes.push(\n          <mesh key={Math.random()} material={clipMaterial} position={[x/5, y/5, z/5]} castShadow>\n            <boxGeometry args={[0.18, 0.18, 0.18]} />\n          </mesh>\n        )\n      }\n\n  return (\n    <>\n      <group ref={meshRef}>\n        {meshes}\n      </group>\n    </>\n  )\n}\n\nconst VolumeVisualization = () => {\n  volumeVisualization = new THREE.Group()\n  volumeVisualization.visible = false\n  const planeGeometry = new THREE.PlaneGeometry( 3, 3, 1, 1 )\n\n  const color = new THREE.Color()\n  for (let i = 0, n = Planes.length; i !== n; ++ i) {\n    const material = new THREE.MeshBasicMaterial( {\n      color: color.setHSL(i / n, 0.5, 0.5).getHex(),\n      side: THREE.DoubleSide,\n\n      opacity: 0.2,\n      transparent: true,\n\n      // clip to the others to show the volume (wildly\n      // intersecting transparent planes look bad)\n      clippingPlanes: clipMaterial.clippingPlanes.\n        filter((_: any, j: number) => {\n          return j !== i\n        })\n\n      // no need to enable shadow clipping - the plane\n      // visualization does not cast shadows\n    })\n\n    const mesh = new THREE.Mesh(planeGeometry, material)\n    mesh.matrixAutoUpdate = false\n\n    volumeVisualization.add(mesh)\n  }\n\n  return (\n    <primitive object={volumeVisualization} />    \n  )\n}\n\nconst Ground = () => {\n  return (\n    <mesh rotation={[-Math.PI / 2, 0, 0]} scale={3} receiveShadow>\n      <planeGeometry args={[3, 3, 1, 1]} />\n      <meshPhongMaterial color={0xa0adaf} shininess={10} />\n    </mesh>\n  )\n}\n\nconst Example = () => {\n  return (\n    <Canvas camera={{position: [0, 1.5, 3], fov: 36, aspect: aspect_ratio, near: 0.25, far: 16}} shadows>\n      <color attach='background' args={['black']} />\n      <Light />\n      <Meshes />\n      <Ground />\n      <VolumeVisualization />\n      <Controls />\n      <OrbitControls target={[0, 1, 0]} minDistance={1} maxDistance={8} />\n    </Canvas>\n  )\n}\n\nexport default Example"],"names":["canvas_width","window","innerWidth","canvas_height","innerHeight","aspect_ratio","clipMaterial","globalClippingPlanes","volumeVisualization","planeToMatrix","xAxis","THREE","yAxis","trans","plane","zAxis","normal","matrix","Math","abs","x","z","set","y","crossVectors","normalize","coplanarPoint","createPlanes","n","result","Array","i","assignTransformedPlanes","planesOut","planesIn","length","copy","applyMatrix4","setObjectWorldMatrix","object","parent","matrixWorld","invert","Planes","vertices","indices","j","a","b","c","setFromCoplanarPoints","planesFromMesh","SQRT1_2","PlaneMatrices","map","GlobalClippingPlanes","innerRadius","angle","PI","cos","sin","constant","cylindricalPlanes","Empty","Object","freeze","transform","tmpMatrix","Controls","gl","useThree","clippingPlanes","localClippingEnabled","useControls","value","onChange","v","visible","clipShadows","Light","args","color","intensity","penumbra","position","castShadow","attach","Meshes","shininess","side","meshRef","useRef","useFrame","time","clock","getElapsedTime","current","rotation","updateMatrix","bouncy","multiply","makeScale","planeMeshes","children","multiplyMatrices","makeRotationY","meshes","push","material","random","ref","VolumeVisualization","planeGeometry","setHSL","getHex","opacity","transparent","filter","_","mesh","matrixAutoUpdate","add","Ground","scale","receiveShadow","camera","fov","aspect","near","far","shadows","target","minDistance","maxDistance"],"sourceRoot":""}